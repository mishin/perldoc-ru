=encoding utf8

=head1 НАИМЕНОВАНИЕ

perlretut - учебник регулярных выражений Perl

=head1 ОПИСАНИЕ

Этот документ является базовым учебником по пониманию, созданию и
использованию регулярных выражений в Perl. Он служит в качестве дополнения к
справочной странице о регулярных выражениях L<perlre>. Регулярные выражения
являются неотъемлемой частью операторов C<m//>, C<s///>, C<qr//> и C<split>
, также этот учебник пересекается со страницами
L<perlop/"Регексп операторы заключения в кавычки"> и L<perlfunc/split>.

Perl широко известен за свои выдающиеся возможности по обработке текста, и регулярные 
выражения являются одним из китов, стоящих за этой славой. Регулярные 
выражения Perl показывают эффективность и гибкость, неизвестную в большинстве
других компьютерных языков. Освоение даже азов регулярных 
выражений позволит вам манипулировать текстом с удивительной легкостью.

Что такое регулярное выражение? Регулярное выражение это просто строка 
, которая описывает образец или шаблон, который мы должны найти. Шаблон поиска используются теперь повсеместно; 
примерами являются шаблоны, которые вводятся в поисковую систему для поиска веб-страниц
и шаблоны, используемые для получения списка файлов в директории, например, C<ls *.txt>
или  C<dir *.*>. В Perl, шаблоны, описанные регулярными выражениями,
используются для поиска строк, извлечения нужных частей строк, и для 
 операций поиска и замены.

Регулярные выражения имеют незаслуженную репутацию абстрактных
и трудно понимаемых. Регулярные выражения создаются с помощью
простых понятий, таких как условия и циклы и их не сложнее понять,
чем соответствующие условные операторы  C<if> и циклы C<while>
 в самом языке Perl.  Фактически, главная проблема в 
 изучении регулярных выражений, это просто привыкнуть к кратким
обозначениям, которые используются для выражения этих понятий.

Этот учебник сглаживает кривую обучения, обсуждая концепцию регулярных
 выражений, а также их обозначения на множестве примеров. 
 Если вы овладеете первой частью, то будете иметь все инструменты, необходимые для решения
около 98% ваших потребностей. Вторая часть урока для тех, кто 
знаком с основами и голоден для более мощных инструментов. Там
рассматриваются более продвинутые операторы регулярных выражений и
представляют последние передовые инновации.

Примечание: чтобы сэкономить время, 'регулярное выражение' часто сокращают
 как регексп или регекс. Регексп - более естественная аббревиатура, чем регекс, но 
труднее произносится. В документации Perl pod равномерно распределяются сокращения
Регексп и Регекс; в Perl существует более одного способа сокращать его.(there is more than one way to abbreviate it!)
В этом руководстве мы будем использовать регексп.

=head1 Часть 1: Основы

=head2 Простой поиск слова

Простейший регексп это просто слово, или, более обще, строка символов.
Регексп, состоящий из слова, соответствует любой строке, содержащей это слово:

    "Hello World" =~ /World/;  # совпадение

О чём это выражение? C<"Hello World"> - это проста строка, заключённая 
в двойные кавычки.  C<World> - это это регулярное выражение и
заключеное в C<//> слово C</World/> говорит Perl искать вхождение строки.
Оператор C<=~> связывает строку с регекспом и выдает значение true
если регексп совпадает, или false если нет.
 В нашем случае, C<World> совпадает со вторым словом в C<"Hello World">, 
 таким образом выражение истинно. У этой идеи есть несколько вариаций.  Такие выражения
полезны в условных операторах:

    if ("Hello World" =~ /World/) {
        print "Найдено\n";
    }
    else {
        print "Не Найдено\n";
    }

Есть много полезных вариантов на эту тему.
Смысл совпадения может быть полностью изменен при помощи оператора C<!~>:

    if ("Hello World" !~ /World/) {
        print "Не Найдено\n";
    }
    else {
        print "Найдено\n";
    }

Последовательность строк в регексе может быть заменена переменной:

    $greeting = "World";
    if ("Hello World" =~ /$greeting/) {
        print "Найдено\n";
    }
    else {
        print "Не Найдено\n";
    }

Если вы ищите в специальной переменной по умолчанию C<$_>, 
то эту часть C<$_ =~> можно опустить:

    $_ = "Hello World";
    if (/World/) {
        print "Найдено\n";
    }
    else {
        print "Не Найдено\n";
    }

Наконец, разделители по умолчанию C<//> для поиска могут быть изменены на
произвольные разделители, но тогда в начале должны быть буква C<'m'>:

    "Hello World" =~ m!World!;   # найдено, разделители '!'
    "Hello World" =~ m{World};   # найдено, отметим совпадение '{}'
    "/usr/bin/perl" =~ m"/perl"; # найдено после '/usr/bin',
                                 # '/' стал произвольным символом

C</World/>, C<m!World!> и C<m{World}> все представляют собой то же самое. 
Например, когда кавычки (C<">) используются в качестве разделителя, то косая черта
C<'/'>  становится обычным символом и может быть использован в этом регекспе
без проблем.
Давайте рассмотрим, каким образом различные регекспы будет соответствовать 
 C<"Hello World">:

    "Hello World" =~ /world/;  # не найдено
    "Hello World" =~ /o W/;    # найдено
    "Hello World" =~ /oW/;     # не найдено
    "Hello World" =~ /World /; # не найдено

Первый регексп C<world> не совпадает, потому регексп 
учитывает регистр. Второй регексп совпадает потому что подстрока
S<C<'o W'>> встречается в строке S<C<"Hello World">>. Пробельный
 символ ' ' рассматривается как любой другой символ в регекспе и будет 
 найден в этом случае. Отсутствие пробела
 является причиной того, почему третий регексп C<'oW'> не совпадает. Четвертый 
 регексп C<'World '> не совпадает, потому что есть пробел в конце
регекспа, но не в конце строки. Урок здесь состоит в том, что
регекспы должны I<точно> совпадать с частью строки для того,
 чтобы выражение стало истинным.

Если регексп находится больше одного раза в строке, 
Perl будет всегда находить самое первое совпадение в строке:

    "Hello World" =~ /o/;       # найдет 'o' в 'Hello'
    "That hat is red" =~ /hat/; # найдет 'hat' в 'That'

Что касается соответствия символов есть еще несколько пунктов, которые нужно знать.
Во-первых, не все символы могут использоваться, 'как есть' в поиске. Некоторые, называемые B<метасимволами>,
 зарезервированы для использования в описании регекса.
Метасимволы это

    {}[]()^$.|*+?\

Значение каждого из них будет объяснено
в остальной части учебника, но на данный момент, важно только знать
то, что метасимвол может быть найден, если перед ним поставить 
обратную косую черту:

    "2+2=4" =~ /2+2/;    # не найдет, т.к. + это метасимвол
    "2+2=4" =~ /2\+2/;   # найдено, \+ считается обычным знаком +
    "The interval is [0,1)." =~ /[0,1)./     # будет синтаксическая ошибка!
    "The interval is [0,1)." =~ /\[0,1\)\./  # найдет
    "#!/usr/bin/perl" =~ /#!\/usr\/bin\/perl/;  # найдет

В последнем регекспе перед первой косой чертой C<'/'> также ставиться обратная косая черта,
потому что косая черта здесь используется, чтобы разграничить регексп.
Это может привести к СВЗ
(синдрому выступающей зубочистки), однако, выражение можно сделать более читаемым, если
 изменить разделители.

    "#!/usr/bin/perl" =~ m!#\!/usr/bin/perl!;  # читается легче

Символ обратной косой черты C<'\'> является метасимволом и для его поиска нужна еще
одна косая черта:

    'C:\WIN32' =~ /C:\\WIN/;   # найдет

В добавлении к метасимволам, есть некоторые символы ASCII 
которые не имеют печатных аналогов и вместо этого
представлены B<escape-последовательностями>.
Типичными примерами являются  C<\t> для табуляции, C<\n> для символа перехода на новую строку, C<\r>
для возврата каретки и C<\a> для пищалки (или сигнала предупреждения). 
Если о строке думать как о последовательности произвольных байт, то
восьмеричные escape-последовательности, например, C<\033>, или шестнадцатеричные escape-последовательности,
например, C<\x1B> могут быть более естественным представлением для ваших байт.
Вот несколько примеров escape-последовательностей:

    "1000\t2000" =~ m(0\t2)   # найдет
    "1000\n2000" =~ /0\n20/   # найдет
    "1000\t2000" =~ /\000\t2/ # не найдет, "0" не равен "\000"
    "cat"   =~ /\o{143}\x61\x74/ # найдено в кодах ASCII, хотя и странный способ
                                 # искать cat

Если вы уже использовали Perl какое-то время, все эти разговоры об escape-последовательностях
могут показаться знакомыми. Подобные escape-последовательности
 используются в двойных кавычках и фактически регекспы в Perl в основном рассматриваются как
строки в двойных кавычках. Это означает, что переменные также могут использоваться в регекспах.
Подобно строкам в двойных кавычках, значение
переменной в регекспе будет подставлено прежде чем регексп выполнит поиск. 
Итак, мы имеем:                                 

    $foo = 'house';
    'housecat' =~ /$foo/;      # найдено
    'cathouse' =~ /cat$foo/;   # найдено
    'housecat' =~ /${foo}cat/; # найдено

Пока все в порядке. Со знаниями, полученными выше вы можете уже выполнять
поиски регекспом почти любой символьной строки , о которой можно мечтать.
Вот I<очень простая> эмуляция программы grep Unix:

    % cat > simple_grep
    #!/usr/bin/perl
    $regexp = shift;
    while (<>) {
        print if /$regexp/;
    }
    ^D

    % chmod +x simple_grep

    % simple_grep abba /usr/dict/words
    Babbage
    cabbage
    cabbages
    sabbath
    Sabbathize
    Sabbathizes
    sabbatical
    scabbard
    scabbards

Эту программу легко понять.  C<#!/usr/bin/perl> это стандартный 
способ вызвать программу Perl из командной строки.
S<C<$regexp = shift;>> сохраняет первый аргумент командной строки, как
регексп, который будет использоваться, а оставшиеся аргументы командной строки
рассматриваются как файлы. S<C<< while (<>) >>> перебирает все строки во всех входящих
файлах.  Для каждой строки, S<C<print if /$regexp/;>> напечатает строку, если
 регексп будет в ней найден.  В этой строке, оба оператора C<print> и
C</$regexp/> используют переменную по умолчанию C<$_> неявно.

Во всех регекспах выше, если регексп находит соответствие в любой точке строки,
то он считается найденным. Иногда однако, мы хотели бы
указать I<где> в строке регексп должен искать.
Чтобы указать где он должен быть найден, 
мы будем использовать I<якорем> метасимволы C<^> и C<$>. 
Якорь C<^> означает поиск в начале строки , а якорь C<$> означает поиск 
в конце строки или перед символом перевода строки в конце строки. 
Вот как они используются:

    "housekeeper" =~ /keeper/;    # найдено
    "housekeeper" =~ /^keeper/;   # не найдено
    "housekeeper" =~ /keeper$/;   # найдено
    "housekeeper\n" =~ /keeper$/; # найдено

Второй регексп не найдет, т.к. C<^> вынуждает, чтобы C<keeper> 
 искался только в начале строки, но C<"housekeeper"> содержит
keeper начинающийся посередине.  Третий регексп найдет, т.к. 
C<$> принуждает C<keeper> искаться только в конце строки.

Когда одновременно используются и C<^> и C<$> , то регексп 
должен найти и начало и конец строки, таким образом регексп должен
 найти всю строку целиком (совпасть).  

    "keeper" =~ /^keep$/;      # не найдет
    "keeper" =~ /^keeper$/;    # найдет
    ""       =~ /^$/;          # ^$ находит пустую строку

Первый регексп не совпадает, потому что длинее, чем C<keep>.
Поскольку второй регексп совпадает со строкой, то он ее найдет. 
Использование C<^> и C<$> в regexp принуждает к поиску всей строки,
таким образом это дает вам полный контроль над тем, какие строки
 искать, а какие нет. Предположим, что вы ищете парня по имени
bert,  находящегося целиком в строке:

    "dogbert" =~ /bert/;   # найдет, но не то, что хотим

    "dilbert" =~ /^bert/;  # не найдет, но ..
    "bertram" =~ /^bert/;  # найдет, но пока еще не так хорошо

    "bertram" =~ /^bert$/; # не найдет, хорошо
    "dilbert" =~ /^bert$/; # не найдет, хорошо
    "bert"    =~ /^bert$/; # найдет, идеально

Конечно, в случае со строковой константой, ее можно было бы найти
гораздо проще просто использовав сравнение строк  S<C<$string eq 'bert'>> и это было бы
более эффективным. Regexp C<^...$> действительно становится полезным, когда мы
добавляем более мощные конструкции в regexp.

=head2 Использование классов символов

Хотя можно сделать очень много уже со строковыми коснтантами
в виде регекспов выше, мы только прикоснулись к технологии регулярных выражений. 
В этом и последующих разделах мы будем вводить regexp
концепции (и связанные с ними описания метасимволов), что позволит
регексп представлять не только, как последовательность одного символа, но и 
I<целого класса> символов.

Одна из таких концепций это I<классы символов>. Класс символов
позволяет созадать набор возможных символов, а не только одного, 
чтобы соответствовать определенной точке регекспа. Классы символов
обозначаются квадратными скобками <[...]>, с набором возможных 
для сопоставления символов внутри. Вот несколько примеров:

    /cat/;       # найдет 'cat'
    /[bcr]at/;   # найдет 'bat, 'cat', или 'rat'
    /item[0123456789]/;  # найдет 'item0' или ... или 'item9'
    "abc" =~ /[cab]/;    # найдет 'a'

В последнем выражении, даже несмотря на то, что C<'c'> является первым символом в классе, 
самой ранней точкой совпадения регекспа будет C<'a'>.

    /[yY][eE][sS]/;      # найдет 'yes' в регистронезависимом поиске
                         # 'yes', 'Yes', 'YES', etc.

Последний пример показывает обычную задачу: сделать регистронезависимый поиск.
Perl предоставляет путь, чтобы исключить все эти скобки, просто добавив
C<'i'> в конце поисковой строки. Тогда C</[yY][eE][sS]/;>
можно переписать как C</yes/i;>, где C<'i'> означает
без учета регистра и является примером I<модификатора> 
операции поиска. Мы встретим другие модификаторы в этом руководстве позднее.

Мы видели выше в разделе, что там были обычные символы, которые
представляли сами себя и специальные символы, которым необходима
обратная косая черта  C<\> в начале, чтобы представлять себя. То же самое верно в
классах символов, но наборы обычных и специальных символов
внутри класса символов отличаются от тех, которые есть за его пределами. 
Специальными символами для класса символов являются  C<-]\^$>  (и
разделитель шаблона , каким бы он ни был).
C<]>  - специальный, потому что оно обозначает конец класса символов. C<$>
 - специальный, потому что он обозначает скалярную переменную. C<\> - специальный потому что
он используется в escape-последовательности, как показано выше. Вот как
обрабатываются специальные символы  C<]$\>:

   /[\]c]def/; # найдет ']def' или 'cdef'
   $x = 'bcr';
   /[$x]at/;   # найдет 'bat', 'cat', или 'rat'
   /[\$x]at/;  # найдет '$at' или 'xat'
   /[\\$x]at/; # найдет '\at', 'bat, 'cat', или 'rat'

Последние два немного сложнее.  В C<[\$x]>, обратный слеш защищает символ доллара
, таким образом класс символов включает 2 символа C<$> и C<x>.
В C<[\\$x]>, обратный слеш защищен, таким образом C<$x> воспринимается
как переменная и заменяется в стиле двойных кавычек.

Специальный символ C<'-'> представляет из себя опратор диапазона внутри класса,
так что непрерывный набор символов может быть записан, как
диапазон.  С диапазоном, громоздкое C<[0123456789]> и C<[abc...xyz]>
становиться стройным C<[0-9]> и C<[a-z]>.  Вот примеры

    /item[0-9]/;  # найдет 'item0' или ... или 'item9'
    /[0-9bx-z]aa/;  # найдет '0aa', ..., '9aa',
                    # 'baa', 'xaa', 'yaa', or 'zaa'
    /[0-9a-fA-F]/;  # найдет шестнадцатиричную цифру
    /[0-9a-zA-Z_]/; # найдет символ "слова",
                    # которое совпрадает с именем переменной в Perl

Если C<'-'> будет первым или последним символом в классе символов, то он
считается обычным тире; C<[-ab]>, C<[ab-]> и C<[a\-b]> эквивалентны.

Специальный символ C<^> в первой позиции класса
означает I<отрицание класса символов>, которое найдет любой символ, который не присутствует
 в списке в квадратных скобках.  Оба и C<[...]> и C<[^...]> должны найти символы
 или поиск будет неудачным. Тогда

    /[^a]at/;  # не найдет 'aat' или 'at', но найдет
               # все другие 'bat', 'cat, '0at', '%at', и т.д.
    /[^0-9]/;  # найдет нецифровой символ
    /[a^]at/;  # найдет 'aat' или '^at'; здесь '^' - обычный символ

Теперь, даже писать несколько раз C<[0-9]> может надоесть , так
появляется интерес сократить число нажатий клавиш и сделать 
регулярные выражения удобочитаемыми,  Perl
имеет несколько сокращений для общих классов символов, как показано ниже.
С момента введения Юникода, если нет модификатора  C<//a>, то
этот класс символов найдет больше, чем просто несколько символов в
диапазоне ASCII.

=over 4

=item *

\d найдет цифру, не только [0-9] но еще и цифры нероманских языков

=item *

\s найдет пробельный символ, набор [\ \t\r\n\f] и другие

=item *

\w найдет словесный символ (буквацифру или _), не только [0-9a-zA-Z_]
но и цифры и символы из нероманских языков

=item *

\D отрицает \d; представляет другие символы, отличные от цифр, или [^\d]

=item *

\S отрицает \s; представляет любой непробельный символ [^\s]

=item *

\W отрицает \w; представляет любой несловесный символ [^\w]

=item *

Точка '.' найдет любой символ, кроме "\n" (пока не работает модификатор C<//s>, 
как объясняется позднее).

=item *

\N, как и точка, найдет любые символы кроме "\n", но делает это
 независимо, даже, если присутствует модификатор C<//s>.

=back

Модификатор C<//a> появился начиная с  Perl 5.14,  используется, 
чтобы ужесточить поиск \d, \s, и \w и только в ASCII диапазоне.
Полезно не полностью переводить вашу программу на полный Юникод
( в частности и по вопросам безопасности ), когда все, что вам нужно,
 это обработка английскоподобных текстов. ("a" может быть удвоено ,
 используйте C<//aa>, чтобы сделать больше ограничений , предотвращая регистрозависимый поиск
ASCII в не-ASCII символах; в противном случае Юникодный "символ Кельвина"
будет бессистемно соответствовать "k" или "K".)


Сокращения C<\d\s\w\D\S\W> могут быть использованы, как внутри, так и снаружи
класса символов.  Вот примеры использования:

    /\d\d:\d\d:\d\d/; # найдет время в формате hh:mm:ss
    /[\d\s]/;         # найдет любую цифру или пробельный символ
    /\w\W\w/;         # найдет словесный символ, за которым несловесный символ,
                      # за которым символ слова
    /..rt/;           # найдет любые 2 символа и за ними 'rt'
    /end\./;          # найдет 'end.'
    /end[.]/;         # также найдет 'end.'

Т.к. точка это метасимвол, его нужно заэскейпить, чтобы найти обычную точку. 
Поэтому, например, C<\d> и C<\w> - это наборы символов
, неверно думать, о C<[^\d\w]> как C<[\D\W]>; фактически
 C<[^\d\w]> тоже, что и C<[^\w]>, что тоже самое, что и C<[\W]>. 
 Думайте законами Де Моргана!

Якорь удобен в базовых регекспах I<якорь границы  слова>
C<\b>.  Находит границу между словным символом и и несловным символом
 C<\w\W> или C<\W\w>:

    $x = "Housecat catenates house and cat";
    $x =~ /cat/;    # найдет cat в 'housecat'
    $x =~ /\bcat/;  # найдет cat в 'catenates'
    $x =~ /cat\b/;  # найдет cat в 'housecat'
    $x =~ /\bcat\b/;  # найдет 'cat' в конце строки

Замечание к последнему примеру, конец строки здесь подразумевает и конец слова.

Вы можете спросить, почему C<'.'> найдет все, кроме C<"\n"> - почему не все символы? 
Причина в том, что часто при сравнении со строкой
хотят игнорировать символы новой строки. К примеру,
в то время как строка C<"\n"> представляет одну строку, мы хотели бы думать о ней, как о пустой строке.
Тогда

    ""   =~ /^$/;    # найдет
    "\n" =~ /^$/;    # найдет, $ якорь после "\n"

    ""   =~ /./;      # не найдет; требуется символ
    ""   =~ /^.$/;    # не найдет; требуется символ
    "\n" =~ /^.$/;    # не найдет; требуется символ отличный от "\n"
    "a"  =~ /^.$/;    # найдет
    "a\n"  =~ /^.$/;  # найдет, $ якорь после "\n"

Такое поведение удобно, потому что мы обычно хотим игнорировать
символы новой строки, когда мы рассчитываем найти символы в строке. Иногда,
однако мы хотим отслеживать символы новой строки. Мы, возможно, даже хотим поставить
C<^> и C<$> как якорь в начале и в конце линий в пределах
строки, а не только начало и конец строки. Perl
позволяет нам выбирать между игнорированием и обращением внимания на символ новой строки
с помощью модификаторов C<//s> и C<//m>. C<//s> и C<//m>
устанавливается для 
однострочной и многострочной строки и они определяют, рассматривать ли строку
, как одну непрерывной линию или как набор линий. Два
модификаторы влияют на два аспекта того, как регексп будет интерпретироваться: 
1) как C<'.'> определяется класс символов и 2) где могут найтись якори C<^>
и C<$>. Ниже приведены четыре возможных комбинации:

=over 4

=item *

без модификаторов (//): Поведение по умолчанию.  C<'.'> найдет любой символ кроме
C<"\n">.  C<^> найдет только начало строки и
C<$> найдет только конец или перед новой строкой в конце.

=item *

s модификатор (//s): Представляет строку как единую длинную линию.  C<'.'> найдет
любой символ, даже C<"\n">.  C<^> найдет только начало строки
и C<$> найдет только конец перед началом новой строки в конце.

=item *

m модификатор (//m): Представляет строку как набор строк.  C<'.'>
найдет любой символ, кроме C<"\n">.  C<^> и C<$> могут найти
начало и конец I<любой> линиии внутри строки.

=item *

оба модификатора s и m (//sm): Представляют строку как одну длинную линию, но 
позволяют найти множество строк.  C<'.'> найдет любой символ, даже
C<"\n">.  C<^> и C<$>, тем не менее, могут найти начало и конец
 I<любой>  линии внутри строки.

=back

Вот примеры C<//s> и C<//m> в действии:

    $x = "There once was a girl\nWho programmed in Perl\n";

    $x =~ /^Who/;   # не найдет, "Who" не является началом строки
    $x =~ /^Who/s;  # не найдет, "Who" не является началом строки
    $x =~ /^Who/m;  # найдет, "Who" является началом второй строкиm
    $x =~ /^Who/sm; # найдет, "Who" является началом второй строкиm

    $x =~ /girl.Who/;   # не найдет, "." не найдет "\n"
    $x =~ /girl.Who/s;  # найдет, "." найдет "\n"
    $x =~ /girl.Who/m;  # не найдет, "." не найдет "\n"
    $x =~ /girl.Who/sm; # найдет, "." найдет "\n"

Большую часть времени, поведение по умолчанию - это то, что мы хотели, но C<//s> и
C <//m>, иногда очень полезны. Если используется C<//m>, началу
строки по-прежнему может быть сопоставлен C<\A> и в конец строки
все еще может быть сопоставлен с якорем C<\Z> (найти оба конец строки и
символ новой строки перед ним, подобно C<$>) и C<\z> (находит только конец строки):

    $x =~ /^Who/m;   # найдет, "Who" в начале строки
    $x =~ /\AWho/m;  # не найдет, "Who" не является началом всей строки

    $x =~ /girl$/m;  # найдет, "girl" в конце первой строки
    $x =~ /girl\Z/m; # не найдет, "girl" не является концом всей строки

    $x =~ /Perl\Z/m; # найдет, "Perl" это новая строка в конце всей строки поиска
    $x =~ /Perl\z/m; # не найдет, "Perl" не в конце строки

Теперь мы знаем, как сделать выбор среди классов символов в
регекспе. Как насчет выбора среди словесных или символьных строк? Такие
варианты описаны в следующем разделе.

=head2 Найти то или это

Иногда мы хотим, чтобы наш регексп имел возможность искать разные
 слова или символьные строки. Это достигается с помощью метасивола B<или> C<'|'>.
  Чтобы найти C<dog> или C<cat>, мы создаем регекс
C<dog|cat>. Как и прежде, Perl пытается найти соответствие в самом раннем месте строки.  В каждой позиции символа
Perl сначала пытается сопоставить первую альтернативу, C<dog>.  Если
C<dog> не найден, Perl теперь пробует следующую альтернативу, C<cat>.
Если C<cat> тоже не находит, тогда поиск считается неудавшимся и Perl перемещается к следующей позиции в строке.
Вот ряд примеров:

    "cats and dogs" =~ /cat|dog|bird/;  # найдет "cat"
    "cats and dogs" =~ /dog|cat|bird/;  # найдет "cat"

Даже при том, что  C<dog> является первой альтернативой во втором регексе,
C<cat> находится раньше в строке.

    "cats"          =~ /c|ca|cat|cats/; # находит "c"
    "cats"          =~ /cats|cat|ca|c/; # найдет "cats"

В данном положении символов, уже первый элемент из списка позволяет поиску
завершиться успешно. Если некоторые варианты усекают другие, то
располагайте самые длинные вперед, чтобы дать им шанс найтись.

    "cab" =~ /a|b|c/ # найдет "c"
                     # /a|b|c/ == /[abc]/

Последний пример показывает, что символьные классы подобны 
 альтернативным символам. В данной символьной позиции первая
альтернатива позволяет регекспу  успешно завершить поиск.

=head2 Группировка элементов и иерархический поиск

Чередование позволяет регекспу выбирать среди альтернатив, но 
само по себе это является неудовлетворительным. Причина в том, что каждый вариант представляет собой единый
регексп, но иногда мы хотим альтернатив для части регекспа.
Например, предположим, мы хотим искать housecats или
housekeeper. Регексп C<housecat|housekeeper> вписывается в нашу задачу, но является
неэффективным, потому что нам пришлось дважды писать C<house>. Было бы неплохо
иметь постоянную часть регекспа С<house> , а другие части будут иметь альтернативу, как C<cat|keeper>.

B<Группирующие> метасимволы C<()> решают эту проблему. 
Группировка позволяет рассматривать части регекса как отдельную единицу.
Части регекса сгуппированы по ограждающим их скобкам. Таким образом
 мы можем заменить регексп C<housecat|housekeeper> на C<house(cat|keeper)>.
 Регексп C<house(cat|keeper)>означает поиск
C<house> за которым следует либо C<cat> либо C<keeper>.  Вот несколько примеров

    /(a|b)b/;    # найдет 'ab' или 'bb'
    /(^a|b)c/;   # найдет 'ac' в начале строки или 'bc' где угодно

    /(a|b)b/;    # найдет 'ab' или 'bb'
    /(ac|b)b/;   # найдет 'acb' или 'bb'
    /(^a|b)c/;   # найдет 'ac' в начале строки или 'bc' где угодно
    /(a|[bc])d/; # найдет 'ad', 'bd', или 'cd'

    /house(cat|)/;  # найдет или 'housecat' или 'house'
    /house(cat(s|)|)/;  # найдет или 'housecats' или 'housecat' или
                        # 'house'. Обратите внимание на то, что группы могут быть вложены.

    "20" =~ /(19|20|)\d\d/;  # находит пустой элемент выбора '()\d\d',
                             # т.к. '20\d\d' не может найти

Группирующие метасимволы C<()> позволяют еще извлекать части найденной строки. Каждые найденные группы попадают в специальные переменные C<$1>, C<$2>, и т.д.
Они могут быть использованы как обычные переменные:


Элементы выбора ведут себя одинаково как в группах, так и вне их: в данной
позиции строки, крайняя левая альтернатива позволяет регекспу выполнить поиск.
Так, в последнем примере на первой позиции строки C<"20"> соответствует второй вариант,
но нет ничего слева, чтобы найти следующие две цифры C<\d\d>. 
Поэтому Perl переходит к следующему элементу выбора, 
которым является null и это работает, так как
C<"20"> состоит из двух цифр.

Процесс пытается найти первый элемент выбора, смотрит, есть ли совпадение, и
переходя к следующему элементу, при этом возвращаясь в строке
 где попробовали предыдущую альтернативу,если она была неудачна, это называется
I<возвратом> (I<backtracking>). Термин "возврат" приходит от идеи,
что поиск регекспа похож на прогулку в лесу. Успешный поиск регекспа
 это как это как прибытие в пункт назначения. Существует множество возможных
троп одна для каждой позиции строки и каждая из них пытался в
порядке слева направо. У каждой тропы может быть много путей,
некоторые из них успешные, а некоторые являются тупиками. Когда вы
прогуливаетесь по тропе и попадаете в тупик, вам придется отступать вдоль
тропы до более ранней точки, чтобы попробовать другой след. Если вы доберетесь до пункта
назначения, вы немедленно остановитесь и забудете об остальных тропах.
Вы стойкие и только, если вы попробовали все трассы от 
всех троп и не прибудете в пункт назначения,
вы объявляете провал. Чтобы быть конкретным, вот пошаговый анализ того,
что делает Perl, когда он пытается найти регексп

    "abcde" =~ /(abd|abc)(df|d|de)/;

=over 4

=item 0

Начинает с первой буквы в строке 'a'.

=item 1

Пробует первый вариант в первой группе 'abd'.

=item 2

Находим, что после 'a' следует 'b'. Пока все в порядке.

=item 3

'd' в регекспе regexp не соответствует 'c' в последовательности - мертвый
конец. Так возвращаются два знака и выбирают вторую альтернативу в
первой группе 'abc'.

=item 4

Находим 'a' за которым 'b' за которым 'c'. Еще один успех (We are on a roll) 
и поймали первую группу. Устанавливаем 1$ в 'abc'.

=item 5

Переходим ко второй группе и выбираем первый вариант 'df'.

=item 6

Находим 'd'.

=item 7

регексп 'f' не не соответствует 'e' в строке, поэтому это мертвый
конец. Возвращаемся на один символ и выбираем второй вариант во
второй группе 'd'.

=item 8

'd' найдено. Вторая группировка найдена, и $2 равна 'd'.

=item 9

Мы в конце регекспа, и так, мы сделали это! Мы нашли
 'abcd' в строке "abcde".

=back

Есть несколько важных вещей,которые стоит сказать об этом анализе. Во-первых,
третий вариант во второй группе 'de' также находится, но мы
останавливаемся прямо перед ним,в данной позиции символ слева
выигрывает. Во-вторых, мы могли получить успешный поиск с позиции первого символа
 строки 'a'. Если бы не было совпадений на первой
позиции, Perl будет двигаться на вторую позицию символа 'b' и
попытается найти все снова. Только, когда все возможные пути на всех
возможных позициях символов были исчерпаны, Perl сдается
 и объявляет S<C<$string =~ /(abd|abc)(df|d|de)/;>> ложным.

Даже с этой работой соответствие регекспу происходит удивительно быстро. Чтобы это
ускорить, Perl компилирует регексп в компактную последовательность
опкодов, которые часто могут поместиться внутри кэша процессора. Когда код выполняется
, эти опкоды могут потом выполняться на полной скорости и искать очень
быстро.

=head2 Извлечение найденного

Метасимволы группировки  C<()> также служат для совершенно другой
 функции: они позволяют извлекать частей найденной строки.
Бывает  очень полезно узнать, что найдено и 
в целом для обработки текста. Для каждой группы, часть, найденная внутри скобок
 кладется в специальные переменные  C<$1>, C<$2>, и др. Они могут
использоваться так же, как обычные переменные:

    # извлекаем часы, минуты, секунды
    if ($time =~ /(\d\d):(\d\d):(\d\d)/) {    # найде hh:mm:ss формат
	$hours = $1;
	$minutes = $2;
	$seconds = $3;
    }

Теперь мы знаем, что в скалярном контексте,
Now, we know that in scalar context,
S<C<$time =~ /(\d\d):(\d\d):(\d\d)/>> вернет значение правды или лжи.  
В контексте списка, однако, он вернет список найденных значений
C<($1,$2,$3)>.  Таким образом, мы можем написать код более компактно:

    # извлекаем часы, минуты, секунды
    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);

Если группы в регекспе вложенные, то C <$1> получает группу с
самой левой открывающей скобкой, C <$2> следующая открывающая скобка,
и т.д. Вот регексп с вложенными группами:

    /(ab(cd|ef)((gi)|j))/;
     1  2      34

Если регексп найдет, C<$1> содержит строку, начинающуюся с
C<'ab'>, C<$2> равно либо C<'cd'> либо C<'ef'>, C<$3> равно либо
C<'gi'> либо C<'j'>, и C<$4> будет C<'gi'>, как и C<$3>,
или останется неопределенной (undefined).

Для удобства, Perl устанавливает C < $+ настроек в строку, проведенных самым высоким номером
C <$1>, C <$2>,..., который получил назначен (и несколько связанных, C <$^N>
Большинство недавно назначенное значение C <$1>, C <$2>,..., т.е. C <$1>,
C <$2>,..., связанные с правом скобка используется в
матч).
Для удобства, Perl устанавливает C<$+> для строки содержащей наивысший номер
C<$1>, C<$2>,... который был присвоен (и несколько связанных, C<$^N> со значениями
C<$1>, C<$2>,... самые недавно присвоенные; т.е. C<$1>,
C<$2>,... ассоциируются с самыми правыми закрывающимися скобками в шаблоне поиска).


=head2 Обратные ссылки

Тесно связаны с переменными поиска C<$1>, C<$2>,...,
 I<Обратные ссылки> C<\g1>, C<\g2>... Обратные ссылки являются 
соответствующими переменными, которые могут быть использованы I<внутри> регекспа. Это
действительно приятная особенность; то, что найденное в конце регулярного выражения зависит
от того, что найдено ранее в регекспе. Предположим, чт о мыраза подряд найти
слово, встречающееся в тексте два раза подряд, как 'the the'.   Следующий регексп
находит все пары 3-х буквенных слов с пробелом между ними:

    /\b(\w\w\w)\s\g1\b/;

То, что найдено в группирующих скобках присваивается \g1, таким образом такие 3-х буквенные последовательности
 используются для обоих частей.

Аналогичная задача по поиску слов, состоящих из 2-х одинаковых частей:

    % simple_grep '^(\w\w\w\w|\w\w\w|\w\w|\w)\g1$' /usr/dict/words
    beriberi
    booboo
    coco
    mama
    murmur
    papa

Регексп имеет единую группировку, которая рассматривает 4-х буквенные
комбинации, а затем 3-х буквенные сочетания и т.д. и использует C<\g1>, чтобы  искать
повторения. Хотя C<$1> и C<\g1> представляют собой то же самое, аккуратность должна быть
 в использовании соответствующих переменных поиска C<$1>, C<$2>,... только I<вне> регекспа,
  а обратных ссылок C<\g1>, C<\g2>,... только I<внутри> регекспа; не выполнение
  этих требований может привести к удивлению и неудовлетворительным результатам.

=head2 Относительные обратные ссылки

Подсчет открытых круглых скобок, чтобы получить правильный номер для
обратной ссылки приводит к ошибкам, как только есть более чем одна
группа захвата. Более удобная техника стала доступна
с Perl 5.10: относительные обратные ссылки. Для обозначения сразу
первой предыдущей группы захвата можно записать C<\g{-1}>, но следующий
последний доступен через C <\g{-2}> и так далее.

Еще одна хорошая причина, помимо чтения и поддержки кода
для использования относительных обратных иллюстрируется в следующем примере,
где используется простой шаблон для сопоставления своеобразный строк:

    $a99a = '([a-z])(\d)\g2\g1';   # найдет a11a, g22g, x33x, и так далее.

Теперь, когда мы сохранили этот шаблон как удобную последовательность, мы могли бы почувствовать
 соблазн использовать его в качестве части некоторого другого образца:

    $line = "code=e99e";
    if ($line =~ /^(\w+)=$a99a$/){   # неожиданное поведение!
        print "$1 is valid\n";
    } else {
        print "bad line: '$line'\n";
    }

Но шаблон не находится, по крайней мере не так, как можно было бы ожидать. Только
после вставки интерполированного C<$a99a> и глядя на итоговый
полный текст регекспа становится очевидным, что обратные ссылки
 приводят к неприятным последствиям. Подвыражение C<(\w+)> захватывает номер 1 и
понижает группы в C<$a99a> на один ранг. Этого можно избежать
использованием относительных обратных ссылок:

    $a99a = '([a-z])(\d)\g{-1}\g{-2}';  # безопасно для интерполяции


=head2 Именованные обратные ссылки

Perl 5.10 также представил именованные группы захвата и именованные обратные ссылки.
Чтобы присоединить имя к группе захвата, вы пишете, либо
C<<(?<name>...)>> или C<< (?'name'...) >>.  Обратную ссылку можно
потом записать, как C<\g{name}>. Это допустимо для присоединения
 одного и того же имени более чем одной группе, но потом ссылаться можно будет только на самую левую скобку из
одноименного набора. За пределами шаблона именованная 
группа захвата доступна через хэш  C<%+>.

Предположим, что нам нужно найти календарные даты, которые могут быть предоставлены в одном
из трех форматы yyyy-mm-dd, mm/dd/yyyy или dd.mm.yyyy, мы можем написать
три подходящих шаблона, когда мы используем 'd', 'm' и 'y'  ('д', 'м' и 'г') соответственно в качестве
имен групп, захватывая соответствующие компоненты даты.
Поисковая операция сочетает в себе три шаблона как альтернативу:

    $fmt1 = '(?<y>\d\d\d\d)-(?<m>\d\d)-(?<d>\d\d)';
    $fmt2 = '(?<m>\d\d)/(?<d>\d\d)/(?<y>\d\d\d\d)';
    $fmt3 = '(?<d>\d\d)\.(?<m>\d\d)\.(?<y>\d\d\d\d)';
    for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
            print "day=$+{d} month=$+{m} year=$+{y}\n";
        }
    }

Если любая из альтернатив найдется, хэш  C<%+> будет содержать
три пары ключ-значение.

=head2 Альтернативные нумерация групп захвата

Еще одна техника нумерации групп (также начиная с Perl 5.10)
занимается проблемой ссылок на группы внутри набора альтернатив.
Рассмотрим шаблон для сопоставления, время суток, гражданского или военного стиля:

    if ( $time =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/ ){
        # обработка часов и минут
    }

Обработка результатов требует дополнительных выражение if для определения
где C<$1> и C<$2> или C<$3> и C<$4> содержат нужные данные. Будет
проще, если мы могли бы использовать второй вариант как номера группы 1 и 2
Ну это именно то, что дает конструкция C<(?|...)>,
поставленная вокруг целевой альтернативы. Вот расширенная версия
предыдущего шаблона:

    if ( $time =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A-Z][A-Z][A-Z])/ ){
	print "hour=$1 minute=$2 zone=$3\n";
    }

В рамках альтернативной группы нумерации, группирующие номера начинаются в той же
позиции для каждой альтернативы. Внутри групп нумерация продолжает
 повышаться до максимума внутри всех альтернатив.

=head2 Информацию о позиции

In addition to what was matched, Perl also provides the
positions of what was matched as contents of the C<@-> and C<@+>
arrays. C<$-[0]> is the position of the start of the entire match and
C<$+[0]> is the position of the end. Similarly, C<$-[n]> is the
position of the start of the C<$n> match and C<$+[n]> is the position
of the end. If C<$n> is undefined, so are C<$-[n]> and C<$+[n]>. Then
this code

    $x = "Mmm...donut, thought Homer";
    $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/; # matches
    foreach $expr (1..$#-) {
        print "Match $expr: '${$expr}' at position ($-[$expr],$+[$expr])\n";
    }

prints

    Match 1: 'Mmm' at position (0,3)
    Match 2: 'donut' at position (6,11)

Even if there are no groupings in a regexp, it is still possible to
find out what exactly matched in a string.  If you use them, Perl
will set C<$`> to the part of the string before the match, will set C<$&>
to the part of the string that matched, and will set C<$'> to the part
of the string after the match.  An example:

    $x = "the cat caught the mouse";
    $x =~ /cat/;  # $` = 'the ', $& = 'cat', $' = ' caught the mouse'
    $x =~ /the/;  # $` = '', $& = 'the', $' = ' cat caught the mouse'

In the second match, C<$`> equals C<''> because the regexp matched at the
first character position in the string and stopped; it never saw the
second 'the'.  It is important to note that using C<$`> and C<$'>
slows down regexp matching quite a bit, while C<$&> slows it down to a
lesser extent, because if they are used in one regexp in a program,
they are generated for I<all> regexps in the program.  So if raw
performance is a goal of your application, they should be avoided.
If you need to extract the corresponding substrings, use C<@-> and
C<@+> instead:

    $` is the same as substr( $x, 0, $-[0] )
    $& is the same as substr( $x, $-[0], $+[0]-$-[0] )
    $' is the same as substr( $x, $+[0] )

As of Perl 5.10, the C<${^PREMATCH}>, C<${^MATCH}> and C<${^POSTMATCH}>
variables may be used. These are only set if the C</p> modifier is present.
Consequently they do not penalize the rest of the program.

=head2 Non-capturing groupings

A group that is required to bundle a set of alternatives may or may not be
useful as a capturing group.  If it isn't, it just creates a superfluous
addition to the set of available capture group values, inside as well as
outside the regexp.  Non-capturing groupings, denoted by C<(?:regexp)>,
still allow the regexp to be treated as a single unit, but don't establish
a capturing group at the same time.  Both capturing and non-capturing
groupings are allowed to co-exist in the same regexp.  Because there is
no extraction, non-capturing groupings are faster than capturing
groupings.  Non-capturing groupings are also handy for choosing exactly
which parts of a regexp are to be extracted to matching variables:

    # match a number, $1-$4 are set, but we only want $1
    /([+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?)/;

    # match a number faster , only $1 is set
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?)/;

    # match a number, get $1 = whole number, $2 = exponent
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE]([+-]?\d+))?)/;

Non-capturing groupings are also useful for removing nuisance
elements gathered from a split operation where parentheses are
required for some reason:

    $x = '12aba34ba5';
    @num = split /(a|b)+/, $x;    # @num = ('12','a','34','a','5')
    @num = split /(?:a|b)+/, $x;  # @num = ('12','34','5')


=head2 Matching repetitions

The examples in the previous section display an annoying weakness.  We
were only matching 3-letter words, or chunks of words of 4 letters or
less.  We'd like to be able to match words or, more generally, strings
of any length, without writing out tedious alternatives like
C<\w\w\w\w|\w\w\w|\w\w|\w>.

This is exactly the problem the I<quantifier> metacharacters C<?>,
C<*>, C<+>, and C<{}> were created for.  They allow us to delimit the
number of repeats for a portion of a regexp we consider to be a
match.  Quantifiers are put immediately after the character, character
class, or grouping that we want to specify.  They have the following
meanings:

=over 4

=item *

C<a?> means: match 'a' 1 or 0 times

=item *

C<a*> means: match 'a' 0 or more times, i.e., any number of times

=item *

C<a+> means: match 'a' 1 or more times, i.e., at least once

=item *

C<a{n,m}> means: match at least C<n> times, but not more than C<m>
times.

=item *

C<a{n,}> means: match at least C<n> or more times

=item *

C<a{n}> means: match exactly C<n> times

=back

Here are some examples:

    /[a-z]+\s+\d*/;  # match a lowercase word, at least one space, and
                     # any number of digits
    /(\w+)\s+\g1/;    # match doubled words of arbitrary length
    /y(es)?/i;       # matches 'y', 'Y', or a case-insensitive 'yes'
    $year =~ /^\d{2,4}$/;  # make sure year is at least 2 but not more
                           # than 4 digits
    $year =~ /^\d{4}$|^\d{2}$/;    # better match; throw out 3-digit dates
    $year =~ /^\d{2}(\d{2})?$/;  # same thing written differently. However,
                                 # this captures the last two digits in $1
                                 # and the other does not.

    % simple_grep '^(\w+)\g1$' /usr/dict/words   # isn't this easier?
    beriberi
    booboo
    coco
    mama
    murmur
    papa

For all of these quantifiers, Perl will try to match as much of the
string as possible, while still allowing the regexp to succeed.  Thus
with C</a?.../>, Perl will first try to match the regexp with the C<a>
present; if that fails, Perl will try to match the regexp without the
C<a> present.  For the quantifier C<*>, we get the following:

    $x = "the cat in the hat";
    $x =~ /^(.*)(cat)(.*)$/; # matches,
                             # $1 = 'the '
                             # $2 = 'cat'
                             # $3 = ' in the hat'

Which is what we might expect, the match finds the only C<cat> in the
string and locks onto it.  Consider, however, this regexp:

    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 characters match)

One might initially guess that Perl would find the C<at> in C<cat> and
stop there, but that wouldn't give the longest possible string to the
first quantifier C<.*>.  Instead, the first quantifier C<.*> grabs as
much of the string as possible while still having the regexp match.  In
this example, that means having the C<at> sequence with the final C<at>
in the string.  The other important principle illustrated here is that,
when there are two or more elements in a regexp, the I<leftmost>
quantifier, if there is one, gets to grab as much of the string as
possible, leaving the rest of the regexp to fight over scraps.  Thus in
our example, the first quantifier C<.*> grabs most of the string, while
the second quantifier C<.*> gets the empty string.   Quantifiers that
grab as much of the string as possible are called I<maximal match> or
I<greedy> quantifiers.

When a regexp can match a string in several different ways, we can use
the principles above to predict which way the regexp will match:

=over 4

=item *

Principle 0: Taken as a whole, any regexp will be matched at the
earliest possible position in the string.

=item *

Principle 1: In an alternation C<a|b|c...>, the leftmost alternative
that allows a match for the whole regexp will be the one used.

=item *

Principle 2: The maximal matching quantifiers C<?>, C<*>, C<+> and
C<{n,m}> will in general match as much of the string as possible while
still allowing the whole regexp to match.

=item *

Principle 3: If there are two or more elements in a regexp, the
leftmost greedy quantifier, if any, will match as much of the string
as possible while still allowing the whole regexp to match.  The next
leftmost greedy quantifier, if any, will try to match as much of the
string remaining available to it as possible, while still allowing the
whole regexp to match.  And so on, until all the regexp elements are
satisfied.

=back

As we have seen above, Principle 0 overrides the others. The regexp
will be matched as early as possible, with the other principles
determining how the regexp matches at that earliest character
position.

Here is an example of these principles in action:

    $x = "The programming republic of Perl";
    $x =~ /^(.+)(e|r)(.*)$/;  # matches,
                              # $1 = 'The programming republic of Pe'
                              # $2 = 'r'
                              # $3 = 'l'

This regexp matches at the earliest string position, C<'T'>.  One
might think that C<e>, being leftmost in the alternation, would be
matched, but C<r> produces the longest string in the first quantifier.

    $x =~ /(m{1,2})(.*)$/;  # matches,
                            # $1 = 'mm'
                            # $2 = 'ing republic of Perl'

Here, The earliest possible match is at the first C<'m'> in
C<programming>. C<m{1,2}> is the first quantifier, so it gets to match
a maximal C<mm>.

    $x =~ /.*(m{1,2})(.*)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ing republic of Perl'

Here, the regexp matches at the start of the string. The first
quantifier C<.*> grabs as much as possible, leaving just a single
C<'m'> for the second quantifier C<m{1,2}>.

    $x =~ /(.?)(m{1,2})(.*)$/;  # matches,
                                # $1 = 'a'
                                # $2 = 'mm'
                                # $3 = 'ing republic of Perl'

Here, C<.?> eats its maximal one character at the earliest possible
position in the string, C<'a'> in C<programming>, leaving C<m{1,2}>
the opportunity to match both C<m>'s. Finally,

    "aXXXb" =~ /(X*)/; # matches with $1 = ''

because it can match zero copies of C<'X'> at the beginning of the
string.  If you definitely want to match at least one C<'X'>, use
C<X+>, not C<X*>.

Sometimes greed is not good.  At times, we would like quantifiers to
match a I<minimal> piece of string, rather than a maximal piece.  For
this purpose, Larry Wall created the I<minimal match> or
I<non-greedy> quantifiers C<??>, C<*?>, C<+?>, and C<{}?>.  These are
the usual quantifiers with a C<?> appended to them.  They have the
following meanings:

=over 4

=item *

C<a??> means: match 'a' 0 or 1 times. Try 0 first, then 1.

=item *

C<a*?> means: match 'a' 0 or more times, i.e., any number of times,
but as few times as possible

=item *

C<a+?> means: match 'a' 1 or more times, i.e., at least once, but
as few times as possible

=item *

C<a{n,m}?> means: match at least C<n> times, not more than C<m>
times, as few times as possible

=item *

C<a{n,}?> means: match at least C<n> times, but as few times as
possible

=item *

C<a{n}?> means: match exactly C<n> times.  Because we match exactly
C<n> times, C<a{n}?> is equivalent to C<a{n}> and is just there for
notational consistency.

=back

Let's look at the example above, but with minimal quantifiers:

    $x = "The programming republic of Perl";
    $x =~ /^(.+?)(e|r)(.*)$/; # matches,
                              # $1 = 'Th'
                              # $2 = 'e'
                              # $3 = ' programming republic of Perl'

The minimal string that will allow both the start of the string C<^>
and the alternation to match is C<Th>, with the alternation C<e|r>
matching C<e>.  The second quantifier C<.*> is free to gobble up the
rest of the string.

    $x =~ /(m{1,2}?)(.*?)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ming republic of Perl'

The first string position that this regexp can match is at the first
C<'m'> in C<programming>. At this position, the minimal C<m{1,2}?>
matches just one C<'m'>.  Although the second quantifier C<.*?> would
prefer to match no characters, it is constrained by the end-of-string
anchor C<$> to match the rest of the string.

    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # matches,
                                  # $1 = 'The progra'
                                  # $2 = 'm'
                                  # $3 = 'ming republic of Perl'

In this regexp, you might expect the first minimal quantifier C<.*?>
to match the empty string, because it is not constrained by a C<^>
anchor to match the beginning of the word.  Principle 0 applies here,
however.  Because it is possible for the whole regexp to match at the
start of the string, it I<will> match at the start of the string.  Thus
the first quantifier has to match everything up to the first C<m>.  The
second minimal quantifier matches just one C<m> and the third
quantifier matches the rest of the string.

    $x =~ /(.??)(m{1,2})(.*)$/;  # matches,
                                 # $1 = 'a'
                                 # $2 = 'mm'
                                 # $3 = 'ing republic of Perl'

Just as in the previous regexp, the first quantifier C<.??> can match
earliest at position C<'a'>, so it does.  The second quantifier is
greedy, so it matches C<mm>, and the third matches the rest of the
string.

We can modify principle 3 above to take into account non-greedy
quantifiers:

=over 4

=item *

Principle 3: If there are two or more elements in a regexp, the
leftmost greedy (non-greedy) quantifier, if any, will match as much
(little) of the string as possible while still allowing the whole
regexp to match.  The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string remaining
available to it as possible, while still allowing the whole regexp to
match.  And so on, until all the regexp elements are satisfied.

=back

Just like alternation, quantifiers are also susceptible to
backtracking.  Here is a step-by-step analysis of the example

    $x = "the cat in the hat";
    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 matches)

=over 4

=item 0

Start with the first letter in the string 't'.

=item 1

The first quantifier '.*' starts out by matching the whole
string 'the cat in the hat'.

=item 2

'a' in the regexp element 'at' doesn't match the end of the
string.  Backtrack one character.

=item 3

'a' in the regexp element 'at' still doesn't match the last
letter of the string 't', so backtrack one more character.

=item 4

Now we can match the 'a' and the 't'.

=item 5

Move on to the third element '.*'.  Since we are at the end of
the string and '.*' can match 0 times, assign it the empty string.

=item 6

We are done!

=back

Most of the time, all this moving forward and backtracking happens
quickly and searching is fast. There are some pathological regexps,
however, whose execution time exponentially grows with the size of the
string.  A typical structure that blows up in your face is of the form

    /(a|b+)*/;

The problem is the nested indeterminate quantifiers.  There are many
different ways of partitioning a string of length n between the C<+>
and C<*>: one repetition with C<b+> of length n, two repetitions with
the first C<b+> length k and the second with length n-k, m repetitions
whose bits add up to length n, etc.  In fact there are an exponential
number of ways to partition a string as a function of its length.  A
regexp may get lucky and match early in the process, but if there is
no match, Perl will try I<every> possibility before giving up.  So be
careful with nested C<*>'s, C<{n,m}>'s, and C<+>'s.  The book
I<Mastering Regular Expressions> by Jeffrey Friedl gives a wonderful
discussion of this and other efficiency issues.


=head2 Possessive quantifiers

Backtracking during the relentless search for a match may be a waste
of time, particularly when the match is bound to fail.  Consider
the simple pattern

    /^\w+\s+\w+$/; # a word, spaces, a word

Whenever this is applied to a string which doesn't quite meet the
pattern's expectations such as S<C<"abc  ">> or S<C<"abc  def ">>,
the regex engine will backtrack, approximately once for each character
in the string.  But we know that there is no way around taking I<all>
of the initial word characters to match the first repetition, that I<all>
spaces must be eaten by the middle part, and the same goes for the second
word.

With the introduction of the I<possessive quantifiers> in Perl 5.10, we
have a way of instructing the regex engine not to backtrack, with the
usual quantifiers with a C<+> appended to them.  This makes them greedy as
well as stingy; once they succeed they won't give anything back to permit
another solution. They have the following meanings:

=over 4

=item *

C<a{n,m}+> means: match at least C<n> times, not more than C<m> times,
as many times as possible, and don't give anything up. C<a?+> is short
for C<a{0,1}+>

=item *

C<a{n,}+> means: match at least C<n> times, but as many times as possible,
and don't give anything up. C<a*+> is short for C<a{0,}+> and C<a++> is
short for C<a{1,}+>.

=item *

C<a{n}+> means: match exactly C<n> times.  It is just there for
notational consistency.

=back

These possessive quantifiers represent a special case of a more general
concept, the I<independent subexpression>, see below.

As an example where a possessive quantifier is suitable we consider
matching a quoted string, as it appears in several programming languages.
The backslash is used as an escape character that indicates that the
next character is to be taken literally, as another character for the
string.  Therefore, after the opening quote, we expect a (possibly
empty) sequence of alternatives: either some character except an
unescaped quote or backslash or an escaped character.

    /"(?:[^"\\]++|\\.)*+"/;


=head2 Building a regexp

At this point, we have all the basic regexp concepts covered, so let's
give a more involved example of a regular expression.  We will build a
regexp that matches numbers.

The first task in building a regexp is to decide what we want to match
and what we want to exclude.  In our case, we want to match both
integers and floating point numbers and we want to reject any string
that isn't a number.

The next task is to break the problem down into smaller problems that
are easily converted into a regexp.

The simplest case is integers.  These consist of a sequence of digits,
with an optional sign in front.  The digits we can represent with
C<\d+> and the sign can be matched with C<[+-]>.  Thus the integer
regexp is

    /[+-]?\d+/;  # matches integers

A floating point number potentially has a sign, an integral part, a
decimal point, a fractional part, and an exponent.  One or more of these
parts is optional, so we need to check out the different
possibilities.  Floating point numbers which are in proper form include
123., 0.345, .34, -1e6, and 25.4E-72.  As with integers, the sign out
front is completely optional and can be matched by C<[+-]?>.  We can
see that if there is no exponent, floating point numbers must have a
decimal point, otherwise they are integers.  We might be tempted to
model these with C<\d*\.\d*>, but this would also match just a single
decimal point, which is not a number.  So the three cases of floating
point number without exponent are

   /[+-]?\d+\./;  # 1., 321., etc.
   /[+-]?\.\d+/;  # .1, .234, etc.
   /[+-]?\d+\.\d+/;  # 1.0, 30.56, etc.

These can be combined into a single regexp with a three-way alternation:

   /[+-]?(\d+\.\d+|\d+\.|\.\d+)/;  # floating point, no exponent

In this alternation, it is important to put C<'\d+\.\d+'> before
C<'\d+\.'>.  If C<'\d+\.'> were first, the regexp would happily match that
and ignore the fractional part of the number.

Now consider floating point numbers with exponents.  The key
observation here is that I<both> integers and numbers with decimal
points are allowed in front of an exponent.  Then exponents, like the
overall sign, are independent of whether we are matching numbers with
or without decimal points, and can be 'decoupled' from the
mantissa.  The overall form of the regexp now becomes clear:

    /^(optional sign)(integer | f.p. mantissa)(optional exponent)$/;

The exponent is an C<e> or C<E>, followed by an integer.  So the
exponent regexp is

   /[eE][+-]?\d+/;  # exponent

Putting all the parts together, we get a regexp that matches numbers:

   /^[+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+-]?\d+)?$/;  # Ta da!

Long regexps like this may impress your friends, but can be hard to
decipher.  In complex situations like this, the C<//x> modifier for a
match is invaluable.  It allows one to put nearly arbitrary whitespace
and comments into a regexp without affecting their meaning.  Using it,
we can rewrite our 'extended' regexp in the more pleasing form

   /^
      [+-]?         # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ([eE][+-]?\d+)?  # finally, optionally match an exponent
   $/x;

If whitespace is mostly irrelevant, how does one include space
characters in an extended regexp? The answer is to backslash it
S<C<'\ '>> or put it in a character class S<C<[ ]>>.  The same thing
goes for pound signs: use C<\#> or C<[#]>.  For instance, Perl allows
a space between the sign and the mantissa or integer, and we could add
this to our regexp as follows:

   /^
      [+-]?\ *      # first, match an optional sign *and space*
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ([eE][+-]?\d+)?  # finally, optionally match an exponent
   $/x;

In this form, it is easier to see a way to simplify the
alternation.  Alternatives 1, 2, and 4 all start with C<\d+>, so it
could be factored out:

   /^
      [+-]?\ *      # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+       # start out with a ...
          (
              \.\d* # mantissa of the form a.b or a.
          )?        # ? takes care of integers of the form a
         |\.\d+     # mantissa of the form .b
      )
      ([eE][+-]?\d+)?  # finally, optionally match an exponent
   $/x;

or written in the compact form,

    /^[+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/;

This is our final regexp.  To recap, we built a regexp by

=over 4

=item *

specifying the task in detail,

=item *

breaking down the problem into smaller parts,

=item *

translating the small parts into regexps,

=item *

combining the regexps,

=item *

and optimizing the final combined regexp.

=back

These are also the typical steps involved in writing a computer
program.  This makes perfect sense, because regular expressions are
essentially programs written in a little computer language that specifies
patterns.

=head2 Using regular expressions in Perl

The last topic of Part 1 briefly covers how regexps are used in Perl
programs.  Where do they fit into Perl syntax?

We have already introduced the matching operator in its default
C</regexp/> and arbitrary delimiter C<m!regexp!> forms.  We have used
the binding operator C<=~> and its negation C<!~> to test for string
matches.  Associated with the matching operator, we have discussed the
single line C<//s>, multi-line C<//m>, case-insensitive C<//i> and
extended C<//x> modifiers.  There are a few more things you might
want to know about matching operators.

=head3 Prohibiting substitution

If you change C<$pattern> after the first substitution happens, Perl
will ignore it.  If you don't want any substitutions at all, use the
special delimiter C<m''>:

    @pattern = ('Seuss');
    while (<>) {
        print if m'@pattern';  # matches literal '@pattern', not 'Seuss'
    }

Similar to strings, C<m''> acts like apostrophes on a regexp; all other
C<m> delimiters act like quotes.  If the regexp evaluates to the empty string,
the regexp in the I<last successful match> is used instead.  So we have

    "dog" =~ /d/;  # 'd' matches
    "dogbert =~ //;  # this matches the 'd' regexp used before


=head3 Global matching

The final two modifiers we will discuss here,
C<//g> and C<//c>, concern multiple matches.
The modifier C<//g> stands for global matching and allows the
matching operator to match within a string as many times as possible.
In scalar context, successive invocations against a string will have
C<//g> jump from match to match, keeping track of position in the
string as it goes along.  You can get or set the position with the
C<pos()> function.

The use of C<//g> is shown in the following example.  Suppose we have
a string that consists of words separated by spaces.  If we know how
many words there are in advance, we could extract the words using
groupings:

    $x = "cat dog house"; # 3 words
    $x =~ /^\s*(\w+)\s+(\w+)\s+(\w+)\s*$/; # matches,
                                           # $1 = 'cat'
                                           # $2 = 'dog'
                                           # $3 = 'house'

But what if we had an indeterminate number of words? This is the sort
of task C<//g> was made for.  To extract all words, form the simple
regexp C<(\w+)> and loop over all matches with C</(\w+)/g>:

    while ($x =~ /(\w+)/g) {
        print "Word is $1, ends at position ", pos $x, "\n";
    }

prints

    Word is cat, ends at position 3
    Word is dog, ends at position 7
    Word is house, ends at position 13

A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
C<//c>, as in C</regexp/gc>.  The current position in the string is
associated with the string, not the regexp.  This means that different
strings have different positions and their respective positions can be
set or read independently.

In list context, C<//g> returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regexp.  So if
we wanted just the words, we could use

    @words = ($x =~ /(\w+)/g);  # matches,
                                # $words[0] = 'cat'
                                # $words[1] = 'dog'
                                # $words[2] = 'house'

Closely associated with the C<//g> modifier is the C<\G> anchor.  The
C<\G> anchor matches at the point where the previous C<//g> match left
off.  C<\G> allows us to easily do context-sensitive matching:

    $metric = 1;  # use metric units
    ...
    $x = <FILE>;  # read in measurement
    $x =~ /^([+-]?\d+)\s*/g;  # get magnitude
    $weight = $1;
    if ($metric) { # error checking
        print "Units error!" unless $x =~ /\Gkg\./g;
    }
    else {
        print "Units error!" unless $x =~ /\Glbs\./g;
    }
    $x =~ /\G\s+(widget|sprocket)/g;  # continue processing

The combination of C<//g> and C<\G> allows us to process the string a
bit at a time and use arbitrary Perl logic to decide what to do next.
Currently, the C<\G> anchor is only fully supported when used to anchor
to the start of the pattern.

C<\G> is also invaluable in processing fixed-length records with
regexps.  Suppose we have a snippet of coding region DNA, encoded as
base pair letters C<ATCGTTGAAT...> and we want to find all the stop
codons C<TGA>.  In a coding region, codons are 3-letter sequences, so
we can think of the DNA snippet as a sequence of 3-letter records.  The
naive regexp

    # expanded, this is "ATC GTT GAA TGC AAA TGA CAT GAC"
    $dna = "ATCGTTGAATGCAAATGACATGAC";
    $dna =~ /TGA/;

doesn't work; it may match a C<TGA>, but there is no guarantee that
the match is aligned with codon boundaries, e.g., the substring
S<C<GTT GAA>> gives a match.  A better solution is

    while ($dna =~ /(\w\w\w)*?TGA/g) {  # note the minimal *?
        print "Got a TGA stop codon at position ", pos $dna, "\n";
    }

which prints

    Got a TGA stop codon at position 18
    Got a TGA stop codon at position 23

Position 18 is good, but position 23 is bogus.  What happened?

The answer is that our regexp works well until we get past the last
real match.  Then the regexp will fail to match a synchronized C<TGA>
and start stepping ahead one character position at a time, not what we
want.  The solution is to use C<\G> to anchor the match to the codon
alignment:

    while ($dna =~ /\G(\w\w\w)*?TGA/g) {
        print "Got a TGA stop codon at position ", pos $dna, "\n";
    }

This prints

    Got a TGA stop codon at position 18

which is the correct answer.  This example illustrates that it is
important not only to match what is desired, but to reject what is not
desired.

(There are other regexp modifiers that are available, such as
C<//o>, but their specialized uses are beyond the
scope of this introduction.  )

=head3 Search and replace

Regular expressions also play a big role in I<search and replace>
operations in Perl.  Search and replace is accomplished with the
C<s///> operator.  The general form is
C<s/regexp/replacement/modifiers>, with everything we know about
regexps and modifiers applying in this case as well.  The
C<replacement> is a Perl double-quoted string that replaces in the
string whatever is matched with the C<regexp>.  The operator C<=~> is
also used here to associate a string with C<s///>.  If matching
against C<$_>, the S<C<$_ =~>> can be dropped.  If there is a match,
C<s///> returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:

    $x = "Time to feed the cat!";
    $x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
        $more_insistent = 1;
    }
    $y = "'quoted words'";
    $y =~ s/^'(.*)'$/$1/;  # strip single quotes,
                           # $y contains "quoted words"

In the last example, the whole string was matched, but only the part
inside the single quotes was grouped.  With the C<s///> operator, the
matched variables C<$1>, C<$2>, etc. are immediately available for use
in the replacement expression, so we use C<$1> to replace the quoted
string with just what was quoted.  With the global modifier, C<s///g>
will search and replace all occurrences of the regexp in the string:

    $x = "I batted 4 for 4";
    $x =~ s/4/four/;   # doesn't do it all:
                       # $x contains "I batted four for 4"
    $x = "I batted 4 for 4";
    $x =~ s/4/four/g;  # does it all:
                       # $x contains "I batted four for four"

If you prefer 'regex' over 'regexp' in this tutorial, you could use
the following program to replace it:

    % cat > simple_replace
    #!/usr/bin/perl
    $regexp = shift;
    $replacement = shift;
    while (<>) {
        s/$regexp/$replacement/g;
        print;
    }
    ^D

    % simple_replace regexp regex perlretut.pod

In C<simple_replace> we used the C<s///g> modifier to replace all
occurrences of the regexp on each line.  (Even though the regular
expression appears in a loop, Perl is smart enough to compile it
only once.)  As with C<simple_grep>, both the
C<print> and the C<s/$regexp/$replacement/g> use C<$_> implicitly.

If you don't want C<s///> to change your original variable you can use
the non-destructive substitute modifier, C<s///r>.  This changes the
behavior so that C<s///r> returns the final substituted string
(instead of the number of substitutions):

    $x = "I like dogs.";
    $y = $x =~ s/dogs/cats/r;
    print "$x $y\n";

That example will print "I like dogs. I like cats". Notice the original
C<$x> variable has not been affected. The overall
result of the substitution is instead stored in C<$y>. If the
substitution doesn't affect anything then the original string is
returned:

    $x = "I like dogs.";
    $y = $x =~ s/elephants/cougars/r;
    print "$x $y\n"; # prints "I like dogs. I like dogs."

One other interesting thing that the C<s///r> flag allows is chaining
substitutions:

    $x = "Cats are great.";
    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\n";
    # prints "Hedgehogs are great."

A modifier available specifically to search and replace is the
C<s///e> evaluation modifier.  C<s///e> treats the
replacement text as Perl code, rather than a double-quoted
string.  The value that the code returns is substituted for the
matched substring.  C<s///e> is useful if you need to do a bit of
computation in the process of replacing text.  This example counts
character frequencies in a line:

    $x = "Bill the cat";
    $x =~ s/(.)/$chars{$1}++;$1/eg;  # final $1 replaces char with itself
    print "frequency of '$_' is $chars{$_}\n"
        foreach (sort {$chars{$b} <=> $chars{$a}} keys %chars);

This prints

    frequency of ' ' is 2
    frequency of 't' is 2
    frequency of 'l' is 2
    frequency of 'B' is 1
    frequency of 'c' is 1
    frequency of 'e' is 1
    frequency of 'h' is 1
    frequency of 'i' is 1
    frequency of 'a' is 1

As with the match C<m//> operator, C<s///> can use other delimiters,
such as C<s!!!> and C<s{}{}>, and even C<s{}//>.  If single quotes are
used C<s'''>, then the regexp and replacement are
treated as single-quoted strings and there are no
variable substitutions.  C<s///> in list context
returns the same thing as in scalar context, i.e., the number of
matches.

=head3 The split function

The C<split()> function is another place where a regexp is used.
C<split /regexp/, string, limit> separates the C<string> operand into
a list of substrings and returns that list.  The regexp must be designed
to match whatever constitutes the separators for the desired substrings.
The C<limit>, if present, constrains splitting into no more than C<limit>
number of strings.  For example, to split a string into words, use

    $x = "Calvin and Hobbes";
    @words = split /\s+/, $x;  # $word[0] = 'Calvin'
                               # $word[1] = 'and'
                               # $word[2] = 'Hobbes'

If the empty regexp C<//> is used, the regexp always matches and
the string is split into individual characters.  If the regexp has
groupings, then the resulting list contains the matched substrings from the
groupings as well.  For instance,

    $x = "/usr/bin/perl";
    @dirs = split m!/!, $x;  # $dirs[0] = ''
                             # $dirs[1] = 'usr'
                             # $dirs[2] = 'bin'
                             # $dirs[3] = 'perl'
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'
                                # $parts[5] = '/'
                                # $parts[6] = 'perl'

Since the first character of $x matched the regexp, C<split> prepended
an empty initial element to the list.

If you have read this far, congratulations! You now have all the basic
tools needed to use regular expressions to solve a wide range of text
processing problems.  If this is your first time through the tutorial,
why not stop here and play around with regexps a while....  S<Part 2>
concerns the more esoteric aspects of regular expressions and those
concepts certainly aren't needed right at the start.

=head1 Part 2: Power tools

OK, you know the basics of regexps and you want to know more.  If
matching regular expressions is analogous to a walk in the woods, then
the tools discussed in Part 1 are analogous to topo maps and a
compass, basic tools we use all the time.  Most of the tools in part 2
are analogous to flare guns and satellite phones.  They aren't used
too often on a hike, but when we are stuck, they can be invaluable.

What follows are the more advanced, less used, or sometimes esoteric
capabilities of Perl regexps.  In Part 2, we will assume you are
comfortable with the basics and concentrate on the advanced features.

=head2 More on characters, strings, and character classes

There are a number of escape sequences and character classes that we
haven't covered yet.

There are several escape sequences that convert characters or strings
between upper and lower case, and they are also available within
patterns.  C<\l> and C<\u> convert the next character to lower or
upper case, respectively:

    $x = "perl";
    $string =~ /\u$x/;  # matches 'Perl' in $string
    $x = "M(rs?|s)\\."; # note the double backslash
    $string =~ /\l$x/;  # matches 'mr.', 'mrs.', and 'ms.',

A C<\L> or C<\U> indicates a lasting conversion of case, until
terminated by C<\E> or thrown over by another C<\U> or C<\L>:

    $x = "This word is in lower case:\L SHOUT\E";
    $x =~ /shout/;       # matches
    $x = "I STILL KEYPUNCH CARDS FOR MY 360"
    $x =~ /\Ukeypunch/;  # matches punch card string

If there is no C<\E>, case is converted until the end of the
string. The regexps C<\L\u$word> or C<\u\L$word> convert the first
character of C<$word> to uppercase and the rest of the characters to
lowercase.

Control characters can be escaped with C<\c>, so that a control-Z
character would be matched with C<\cZ>.  The escape sequence
C<\Q>...C<\E> quotes, or protects most non-alphabetic characters.   For
instance,

    $x = "\QThat !^*&%~& cat!";
    $x =~ /\Q!^*&%~&\E/;  # check for rough language

It does not protect C<$> or C<@>, so that variables can still be
substituted.

C<\Q>, C<\L>, C<\l>, C<\U>, C<\u> and C<\E> are actually part of
double-quotish syntax, and not part of regexp syntax proper.  They will
work if they appear in a regular expression embedded directly in a
program, but not when contained in a string that is interpolated in a
pattern.

Perl regexps can handle more than just the
standard ASCII character set.  Perl supports I<Unicode>, a standard
for representing the alphabets from virtually all of the world's written
languages, and a host of symbols.  Perl's text strings are Unicode strings, so
they can contain characters with a value (codepoint or character number) higher
than 255.

What does this mean for regexps? Well, regexp users don't need to know
much about Perl's internal representation of strings.  But they do need
to know 1) how to represent Unicode characters in a regexp and 2) that
a matching operation will treat the string to be searched as a sequence
of characters, not bytes.  The answer to 1) is that Unicode characters
greater than C<chr(255)> are represented using the C<\x{hex}> notation, because
\x hex (without curly braces) doesn't go further than 255.  (Starting in Perl
5.14, if you're an octal fan, you can also use C<\o{oct}>.)

    /\x{263a}/;  # match a Unicode smiley face :)

B<NOTE>: In Perl 5.6.0 it used to be that one needed to say C<use
utf8> to use any Unicode features.  This is no more the case: for
almost all Unicode processing, the explicit C<utf8> pragma is not
needed.  (The only case where it matters is if your Perl script is in
Unicode and encoded in UTF-8, then an explicit C<use utf8> is needed.)

Figuring out the hexadecimal sequence of a Unicode character you want
or deciphering someone else's hexadecimal Unicode regexp is about as
much fun as programming in machine code.  So another way to specify
Unicode characters is to use the I<named character> escape
sequence C<\N{I<name>}>.  I<name> is a name for the Unicode character, as
specified in the Unicode standard.  For instance, if we wanted to
represent or match the astrological sign for the planet Mercury, we
could use

    $x = "abc\N{MERCURY}def";
    $x =~ /\N{MERCURY}/;   # matches

One can also use "short" names:

    print "\N{GREEK SMALL LETTER SIGMA} is called sigma.\n";
    print "\N{greek:Sigma} is an upper-case sigma.\n";

You can also restrict names to a certain alphabet by specifying the
L<charnames> pragma:

    use charnames qw(greek);
    print "\N{sigma} is Greek sigma\n";

An index of character names is available on-line from the Unicode
Consortium, L<http://www.unicode.org/charts/charindex.html>; explanatory
material with links to other resources at
L<http://www.unicode.org/standard/where>.

The answer to requirement 2) is that a regexp (mostly)
uses Unicode characters.  The "mostly" is for messy backward
compatibility reasons, but starting in Perl 5.14, any regex compiled in
the scope of a C<use feature 'unicode_strings'> (which is automatically
turned on within the scope of a C<use 5.012> or higher) will turn that
"mostly" into "always".  If you want to handle Unicode properly, you
should ensure that C<'unicode_strings'> is turned on.
Internally, this is encoded to bytes using either UTF-8 or a native 8
bit encoding, depending on the history of the string, but conceptually
it is a sequence of characters, not bytes. See L<perlunitut> for a
tutorial about that.

Let us now discuss Unicode character classes.  Just as with Unicode
characters, there are named Unicode character classes represented by the
C<\p{name}> escape sequence.  Closely associated is the C<\P{name}>
character class, which is the negation of the C<\p{name}> class.  For
example, to match lower and uppercase characters,

    $x = "BOB";
    $x =~ /^\p{IsUpper}/;   # matches, uppercase char class
    $x =~ /^\P{IsUpper}/;   # doesn't match, char class sans uppercase
    $x =~ /^\p{IsLower}/;   # doesn't match, lowercase char class
    $x =~ /^\P{IsLower}/;   # matches, char class sans lowercase

(The "Is" is optional.)

Here is the association between some Perl named classes and the
traditional Unicode classes:

    Perl class name  Unicode class name or regular expression

    IsAlpha          /^[LM]/
    IsAlnum          /^[LMN]/
    IsASCII          $code <= 127
    IsCntrl          /^C/
    IsBlank          $code =~ /^(0020|0009)$/ || /^Z[^lp]/
    IsDigit          Nd
    IsGraph          /^([LMNPS]|Co)/
    IsLower          Ll
    IsPrint          /^([LMNPS]|Co|Zs)/
    IsPunct          /^P/
    IsSpace          /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
    IsSpacePerl      /^Z/ || ($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/
    IsUpper          /^L[ut]/
    IsWord           /^[LMN]/ || $code eq "005F"
    IsXDigit         $code =~ /^00(3[0-9]|[46][1-6])$/

You can also use the official Unicode class names with C<\p> and
C<\P>, like C<\p{L}> for Unicode 'letters', C<\p{Lu}> for uppercase
letters, or C<\P{Nd}> for non-digits.  If a C<name> is just one
letter, the braces can be dropped.  For instance, C<\pM> is the
character class of Unicode 'marks', for example accent marks.
For the full list see L<perlunicode>.

Unicode has also been separated into various sets of characters
which you can test with C<\p{...}> (in) and C<\P{...}> (not in).
To test whether a character is (or is not) an element of a script
you would use the script name, for example C<\p{Latin}>, C<\p{Greek}>,
or C<\P{Katakana}>.

What we have described so far is the single form of the C<\p{...}> character
classes.  There is also a compound form which you may run into.  These
look like C<\p{name=value}> or C<\p{name:value}> (the equals sign and colon
can be used interchangeably).  These are more general than the single form,
and in fact most of the single forms are just Perl-defined shortcuts for common
compound forms.  For example, the script examples in the previous paragraph
could be written equivalently as C<\p{Script=Latin}>, C<\p{Script:Greek}>, and
C<\P{script=katakana}> (case is irrelevant between the C<{}> braces).  You may
never have to use the compound forms, but sometimes it is necessary, and their
use can make your code easier to understand.

C<\X> is an abbreviation for a character class that comprises
a Unicode I<extended grapheme cluster>.  This represents a "logical character":
what appears to be a single character, but may be represented internally by more
than one.  As an example, using the Unicode full names, e.g., S<C<A + COMBINING
RING>> is a grapheme cluster with base character C<A> and combining character
S<C<COMBINING RING>>, which translates in Danish to A with the circle atop it,
as in the word Angstrom.

For the full and latest information about Unicode see the latest
Unicode standard, or the Unicode Consortium's website L<http://www.unicode.org>

As if all those classes weren't enough, Perl also defines POSIX-style
character classes.  These have the form C<[:name:]>, with C<name> the
name of the POSIX class.  The POSIX classes are C<alpha>, C<alnum>,
C<ascii>, C<cntrl>, C<digit>, C<graph>, C<lower>, C<print>, C<punct>,
C<space>, C<upper>, and C<xdigit>, and two extensions, C<word> (a Perl
extension to match C<\w>), and C<blank> (a GNU extension).  The C<//a>
modifier restricts these to matching just in the ASCII range; otherwise
they can match the same as their corresponding Perl Unicode classes:
C<[:upper:]> is the same as C<\p{IsUpper}>, etc.  (There are some
exceptions and gotchas with this; see L<perlrecharclass> for a full
discussion.) The C<[:digit:]>, C<[:word:]>, and
C<[:space:]> correspond to the familiar C<\d>, C<\w>, and C<\s>
character classes.  To negate a POSIX class, put a C<^> in front of
the name, so that, e.g., C<[:^digit:]> corresponds to C<\D> and, under
Unicode, C<\P{IsDigit}>.  The Unicode and POSIX character classes can
be used just like C<\d>, with the exception that POSIX character
classes can only be used inside of a character class:

    /\s+[abc[:digit:]xyz]\s*/;  # match a,b,c,x,y,z, or a digit
    /^=item\s[[:digit:]]/;      # match '=item',
                                # followed by a space and a digit
    /\s+[abc\p{IsDigit}xyz]\s+/;  # match a,b,c,x,y,z, or a digit
    /^=item\s\p{IsDigit}/;        # match '=item',
                                  # followed by a space and a digit

Whew! That is all the rest of the characters and character classes.

=head2 Compiling and saving regular expressions

In Part 1 we mentioned that Perl compiles a regexp into a compact
sequence of opcodes.  Thus, a compiled regexp is a data structure
that can be stored once and used again and again.  The regexp quote
C<qr//> does exactly that: C<qr/string/> compiles the C<string> as a
regexp and transforms the result into a form that can be assigned to a
variable:

    $reg = qr/foo+bar?/;  # reg contains a compiled regexp

Then C<$reg> can be used as a regexp:

    $x = "fooooba";
    $x =~ $reg;     # matches, just like /foo+bar?/
    $x =~ /$reg/;   # same thing, alternate form

C<$reg> can also be interpolated into a larger regexp:

    $x =~ /(abc)?$reg/;  # still matches

As with the matching operator, the regexp quote can use different
delimiters, e.g., C<qr!!>, C<qr{}> or C<qr~~>.  Apostrophes
as delimiters (C<qr''>) inhibit any interpolation.

Pre-compiled regexps are useful for creating dynamic matches that
don't need to be recompiled each time they are encountered.  Using
pre-compiled regexps, we write a C<grep_step> program which greps
for a sequence of patterns, advancing to the next pattern as soon
as one has been satisfied.

    % cat > grep_step
    #!/usr/bin/perl
    # grep_step - match <number> regexps, one after the other
    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...

    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    @compiled = map qr/$_/, @regexp;
    while ($line = <>) {
        if ($line =~ /$compiled[0]/) {
            print $line;
            shift @compiled;
            last unless @compiled;
        }
    }
    ^D

    % grep_step 3 shift print last grep_step
    $number = shift;
            print $line;
            last unless @compiled;

Storing pre-compiled regexps in an array C<@compiled> allows us to
simply loop through the regexps without any recompilation, thus gaining
flexibility without sacrificing speed.


=head2 Composing regular expressions at runtime

Backtracking is more efficient than repeated tries with different regular
expressions.  If there are several regular expressions and a match with
any of them is acceptable, then it is possible to combine them into a set
of alternatives.  If the individual expressions are input data, this
can be done by programming a join operation.  We'll exploit this idea in
an improved version of the C<simple_grep> program: a program that matches
multiple patterns:

    % cat > multi_grep
    #!/usr/bin/perl
    # multi_grep - match any of <number> regexps
    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...

    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    $pattern = join '|', @regexp;

    while ($line = <>) {
        print $line if $line =~ /$pattern/;
    }
    ^D

    % multi_grep 2 shift for multi_grep
    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);

Sometimes it is advantageous to construct a pattern from the I<input>
that is to be analyzed and use the permissible values on the left
hand side of the matching operations.  As an example for this somewhat
paradoxical situation, let's assume that our input contains a command
verb which should match one out of a set of available command verbs,
with the additional twist that commands may be abbreviated as long as
the given string is unique. The program below demonstrates the basic
algorithm.

    % cat > keymatch
    #!/usr/bin/perl
    $kwds = 'copy compare list print';
    while( $command = <> ){
        $command =~ s/^\s+|\s+$//g;  # trim leading and trailing spaces
        if( ( @matches = $kwds =~ /\b$command\w*/g ) == 1 ){
            print "command: '@matches'\n";
        } elsif( @matches == 0 ){
            print "no such command: '$command'\n";
        } else {
            print "not unique: '$command' (could be one of: @matches)\n";
        }
    }
    ^D

    % keymatch
    li
    command: 'list'
    co
    not unique: 'co' (could be one of: copy compare)
    printer
    no such command: 'printer'

Rather than trying to match the input against the keywords, we match the
combined set of keywords against the input.  The pattern matching
operation S<C<$kwds =~ /\b($command\w*)/g>> does several things at the
same time. It makes sure that the given command begins where a keyword
begins (C<\b>). It tolerates abbreviations due to the added C<\w*>. It
tells us the number of matches (C<scalar @matches>) and all the keywords
that were actually matched.  You could hardly ask for more.

=head2 Embedding comments and modifiers in a regular expression

Starting with this section, we will be discussing Perl's set of
I<extended patterns>.  These are extensions to the traditional regular
expression syntax that provide powerful new tools for pattern
matching.  We have already seen extensions in the form of the minimal
matching constructs C<??>, C<*?>, C<+?>, C<{n,m}?>, and C<{n,}?>.  Most
of the extensions below have the form C<(?char...)>, where the
C<char> is a character that determines the type of extension.

The first extension is an embedded comment C<(?#text)>.  This embeds a
comment into the regular expression without affecting its meaning.  The
comment should not have any closing parentheses in the text.  An
example is

    /(?# Match an integer:)[+-]?\d+/;

This style of commenting has been largely superseded by the raw,
freeform commenting that is allowed with the C<//x> modifier.

Most modifiers, such as C<//i>, C<//m>, C<//s> and C<//x> (or any
combination thereof) can also be embedded in
a regexp using C<(?i)>, C<(?m)>, C<(?s)>, and C<(?x)>.  For instance,

    /(?i)yes/;  # match 'yes' case insensitively
    /yes/i;     # same thing
    /(?x)(          # freeform version of an integer regexp
             [+-]?  # match an optional sign
             \d+    # match a sequence of digits
         )
    /x;

Embedded modifiers can have two important advantages over the usual
modifiers.  Embedded modifiers allow a custom set of modifiers to
I<each> regexp pattern.  This is great for matching an array of regexps
that must have different modifiers:

    $pattern[0] = '(?i)doctor';
    $pattern[1] = 'Johnson';
    ...
    while (<>) {
        foreach $patt (@pattern) {
            print if /$patt/;
        }
    }

The second advantage is that embedded modifiers (except C<//p>, which
modifies the entire regexp) only affect the regexp
inside the group the embedded modifier is contained in.  So grouping
can be used to localize the modifier's effects:

    /Answer: ((?i)yes)/;  # matches 'Answer: yes', 'Answer: YES', etc.

Embedded modifiers can also turn off any modifiers already present
by using, e.g., C<(?-i)>.  Modifiers can also be combined into
a single expression, e.g., C<(?s-i)> turns on single line mode and
turns off case insensitivity.

Embedded modifiers may also be added to a non-capturing grouping.
C<(?i-m:regexp)> is a non-capturing grouping that matches C<regexp>
case insensitively and turns off multi-line mode.


=head2 Looking ahead and looking behind

This section concerns the lookahead and lookbehind assertions.  First,
a little background.

In Perl regular expressions, most regexp elements 'eat up' a certain
amount of string when they match.  For instance, the regexp element
C<[abc}]> eats up one character of the string when it matches, in the
sense that Perl moves to the next character position in the string
after the match.  There are some elements, however, that don't eat up
characters (advance the character position) if they match.  The examples
we have seen so far are the anchors.  The anchor C<^> matches the
beginning of the line, but doesn't eat any characters.  Similarly, the
word boundary anchor C<\b> matches wherever a character matching C<\w>
is next to a character that doesn't, but it doesn't eat up any
characters itself.  Anchors are examples of I<zero-width assertions>:
zero-width, because they consume
no characters, and assertions, because they test some property of the
string.  In the context of our walk in the woods analogy to regexp
matching, most regexp elements move us along a trail, but anchors have
us stop a moment and check our surroundings.  If the local environment
checks out, we can proceed forward.  But if the local environment
doesn't satisfy us, we must backtrack.

Checking the environment entails either looking ahead on the trail,
looking behind, or both.  C<^> looks behind, to see that there are no
characters before.  C<$> looks ahead, to see that there are no
characters after.  C<\b> looks both ahead and behind, to see if the
characters on either side differ in their "word-ness".

The lookahead and lookbehind assertions are generalizations of the
anchor concept.  Lookahead and lookbehind are zero-width assertions
that let us specify which characters we want to test for.  The
lookahead assertion is denoted by C<(?=regexp)> and the lookbehind
assertion is denoted by C<< (?<=fixed-regexp) >>.  Some examples are

    $x = "I catch the housecat 'Tom-cat' with catnip";
    $x =~ /cat(?=\s)/;   # matches 'cat' in 'housecat'
    @catwords = ($x =~ /(?<=\s)cat\w+/g);  # matches,
                                           # $catwords[0] = 'catch'
                                           # $catwords[1] = 'catnip'
    $x =~ /\bcat\b/;  # matches 'cat' in 'Tom-cat'
    $x =~ /(?<=\s)cat(?=\s)/; # doesn't match; no isolated 'cat' in
                              # middle of $x

Note that the parentheses in C<(?=regexp)> and C<< (?<=regexp) >> are
non-capturing, since these are zero-width assertions.  Thus in the
second regexp, the substrings captured are those of the whole regexp
itself.  Lookahead C<(?=regexp)> can match arbitrary regexps, but
lookbehind C<< (?<=fixed-regexp) >> only works for regexps of fixed
width, i.e., a fixed number of characters long.  Thus
C<< (?<=(ab|bc)) >> is fine, but C<< (?<=(ab)*) >> is not.  The
negated versions of the lookahead and lookbehind assertions are
denoted by C<(?!regexp)> and C<< (?<!fixed-regexp) >> respectively.
They evaluate true if the regexps do I<not> match:

    $x = "foobar";
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?<!\s)foo/;  # matches, there is no \s before 'foo'

The C<\C> is unsupported in lookbehind, because the already
treacherous definition of C<\C> would become even more so
when going backwards.

Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components.
Using C</\s+/> alone won't work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split are established
by looking ahead and behind:

    $str = "one two - --6-8";
    @toks = split / \s+              # a run of spaces
                  | (?<=\S) (?=-)    # any non-space followed by '-'
                  | (?<=-)  (?=\S)   # a '-' followed by any non-space
                  /x, $str;          # @toks = qw(one two - - - 6 - 8)


=head2 Using independent subexpressions to prevent backtracking

I<Independent subexpressions> are regular expressions, in the
context of a larger regular expression, that function independently of
the larger regular expression.  That is, they consume as much or as
little of the string as they wish without regard for the ability of
the larger regexp to match.  Independent subexpressions are represented
by C<< (?>regexp) >>.  We can illustrate their behavior by first
considering an ordinary regexp:

    $x = "ab";
    $x =~ /a*ab/;  # matches

This obviously matches, but in the process of matching, the
subexpression C<a*> first grabbed the C<a>.  Doing so, however,
wouldn't allow the whole regexp to match, so after backtracking, C<a*>
eventually gave back the C<a> and matched the empty string.  Here, what
C<a*> matched was I<dependent> on what the rest of the regexp matched.

Contrast that with an independent subexpression:

    $x =~ /(?>a*)ab/;  # doesn't match!

The independent subexpression C<< (?>a*) >> doesn't care about the rest
of the regexp, so it sees an C<a> and grabs it.  Then the rest of the
regexp C<ab> cannot match.  Because C<< (?>a*) >> is independent, there
is no backtracking and the independent subexpression does not give
up its C<a>.  Thus the match of the regexp as a whole fails.  A similar
behavior occurs with completely independent regexps:

    $x = "ab";
    $x =~ /a*/g;   # matches, eats an 'a'
    $x =~ /\Gab/g; # doesn't match, no 'a' available

Here C<//g> and C<\G> create a 'tag team' handoff of the string from
one regexp to the other.  Regexps with an independent subexpression are
much like this, with a handoff of the string to the independent
subexpression, and a handoff of the string back to the enclosing
regexp.

The ability of an independent subexpression to prevent backtracking
can be quite useful.  Suppose we want to match a non-empty string
enclosed in parentheses up to two levels deep.  Then the following
regexp matches:

    $x = "abc(de(fg)h";  # unbalanced parentheses
    $x =~ /\( ( [^()]+ | \([^()]*\) )+ \)/x;

The regexp matches an open parenthesis, one or more copies of an
alternation, and a close parenthesis.  The alternation is two-way, with
the first alternative C<[^()]+> matching a substring with no
parentheses and the second alternative C<\([^()]*\)>  matching a
substring delimited by parentheses.  The problem with this regexp is
that it is pathological: it has nested indeterminate quantifiers
of the form C<(a+|b)+>.  We discussed in Part 1 how nested quantifiers
like this could take an exponentially long time to execute if there
was no match possible.  To prevent the exponential blowup, we need to
prevent useless backtracking at some point.  This can be done by
enclosing the inner quantifier as an independent subexpression:

    $x =~ /\( ( (?>[^()]+) | \([^()]*\) )+ \)/x;

Here, C<< (?>[^()]+) >> breaks the degeneracy of string partitioning
by gobbling up as much of the string as possible and keeping it.   Then
match failures fail much more quickly.


=head2 Conditional expressions

A I<conditional expression> is a form of if-then-else statement
that allows one to choose which patterns are to be matched, based on
some condition.  There are two types of conditional expression:
C<(?(condition)yes-regexp)> and
C<(?(condition)yes-regexp|no-regexp)>.  C<(?(condition)yes-regexp)> is
like an S<C<'if () {}'>> statement in Perl.  If the C<condition> is true,
the C<yes-regexp> will be matched.  If the C<condition> is false, the
C<yes-regexp> will be skipped and Perl will move onto the next regexp
element.  The second form is like an S<C<'if () {} else {}'>> statement
in Perl.  If the C<condition> is true, the C<yes-regexp> will be
matched, otherwise the C<no-regexp> will be matched.

The C<condition> can have several forms.  The first form is simply an
integer in parentheses C<(integer)>.  It is true if the corresponding
backreference C<\integer> matched earlier in the regexp.  The same
thing can be done with a name associated with a capture group, written
as C<< (<name>) >> or C<< ('name') >>.  The second form is a bare
zero-width assertion C<(?...)>, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section).  The third set of forms
provides tests that return true if the expression is executed within
a recursion (C<(R)>) or is being called from some capturing group,
referenced either by number (C<(R1)>, C<(R2)>,...) or by name
(C<(R&name)>).

The integer or name form of the C<condition> allows us to choose,
with more flexibility, what to match based on what matched earlier in the
regexp. This searches for words of the form C<"$x$x"> or C<"$x$y$y$x">:

    % simple_grep '^(\w+)(\w+)?(?(2)\g2\g1|\g1)$' /usr/dict/words
    beriberi
    coco
    couscous
    deed
    ...
    toot
    toto
    tutu

The lookbehind C<condition> allows, along with backreferences,
an earlier part of the match to influence a later part of the
match.  For instance,

    /[ATGC]+(?(?<=AA)G|C)$/;

matches a DNA sequence such that it either ends in C<AAG>, or some
other base pair combination and C<C>.  Note that the form is
C<< (?(?<=AA)G|C) >> and not C<< (?((?<=AA))G|C) >>; for the
lookahead, lookbehind or code assertions, the parentheses around the
conditional are not needed.


=head2 Defining named patterns

Some regular expressions use identical subpatterns in several places.
Starting with Perl 5.10, it is possible to define named subpatterns in
a section of the pattern so that they can be called up by name
anywhere in the pattern.  This syntactic pattern for this definition
group is C<< (?(DEFINE)(?<name>pattern)...) >>.  An insertion
of a named pattern is written as C<(?&name)>.

The example below illustrates this feature using the pattern for
floating point numbers that was presented earlier on.  The three
subpatterns that are used more than once are the optional sign, the
digit sequence for an integer and the decimal fraction.  The DEFINE
group at the end of the pattern contains their definition.  Notice
that the decimal fraction pattern is the first place where we can
reuse the integer pattern.

   /^ (?&osg)\ * ( (?&int)(?&dec)? | (?&dec) )
      (?: [eE](?&osg)(?&int) )?
    $
    (?(DEFINE)
      (?<osg>[-+]?)         # optional sign
      (?<int>\d++)          # integer
      (?<dec>\.(?&int))     # decimal fraction
    )/x


=head2 Recursive patterns

This feature (introduced in Perl 5.10) significantly extends the
power of Perl's pattern matching.  By referring to some other
capture group anywhere in the pattern with the construct
C<(?group-ref)>, the I<pattern> within the referenced group is used
as an independent subpattern in place of the group reference itself.
Because the group reference may be contained I<within> the group it
refers to, it is now possible to apply pattern matching to tasks that
hitherto required a recursive parser.

To illustrate this feature, we'll design a pattern that matches if
a string contains a palindrome. (This is a word or a sentence that,
while ignoring spaces, interpunctuation and case, reads the same backwards
as forwards. We begin by observing that the empty string or a string
containing just one word character is a palindrome. Otherwise it must
have a word character up front and the same at its end, with another
palindrome in between.

    /(?: (\w) (?...Here be a palindrome...) \g{-1} | \w? )/x

Adding C<\W*> at either end to eliminate what is to be ignored, we already
have the full pattern:

    my $pp = qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix;
    for $s ( "saippuakauppias", "A man, a plan, a canal: Panama!" ){
        print "'$s' is a palindrome\n" if $s =~ /$pp/;
    }

In C<(?...)> both absolute and relative backreferences may be used.
The entire pattern can be reinserted with C<(?R)> or C<(?0)>.
If you prefer to name your groups, you can use C<(?&name)> to
recurse into that group.


=head2 A bit of magic: executing Perl code in a regular expression

Normally, regexps are a part of Perl expressions.
I<Code evaluation> expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp.  A code evaluation
expression is denoted C<(?{code})>, with I<code> a string of Perl
statements.

Be warned that this feature is considered experimental, and may be
changed without notice.

Code expressions are zero-width assertions, and the value they return
depends on their environment.  There are two possibilities: either the
code expression is used as a conditional in a conditional expression
C<(?(condition)...)>, or it is not.  If the code expression is a
conditional, the code is evaluated and the result (i.e., the result of
the last statement) is used to determine truth or falsehood.  If the
code expression is not used as a conditional, the assertion always
evaluates true and the result is put into the special variable
C<$^R>.  The variable C<$^R> can then be used in code expressions later
in the regexp.  Here are some silly examples:

    $x = "abcdef";
    $x =~ /abc(?{print "Hi Mom!";})def/; # matches,
                                         # prints 'Hi Mom!'
    $x =~ /aaa(?{print "Hi Mom!";})def/; # doesn't match,
                                         # no 'Hi Mom!'

Pay careful attention to the next example:

    $x =~ /abc(?{print "Hi Mom!";})ddd/; # doesn't match,
                                         # no 'Hi Mom!'
                                         # but why not?

At first glance, you'd think that it shouldn't print, because obviously
the C<ddd> isn't going to match the target string. But look at this
example:

    $x =~ /abc(?{print "Hi Mom!";})[dD]dd/; # doesn't match,
                                            # but _does_ print

Hmm. What happened here? If you've been following along, you know that
the above pattern should be effectively (almost) the same as the last one;
enclosing the C<d> in a character class isn't going to change what it
matches. So why does the first not print while the second one does?

The answer lies in the optimizations the regex engine makes. In the first
case, all the engine sees are plain old characters (aside from the
C<?{}> construct). It's smart enough to realize that the string 'ddd'
doesn't occur in our target string before actually running the pattern
through. But in the second case, we've tricked it into thinking that our
pattern is more complicated. It takes a look, sees our
character class, and decides that it will have to actually run the
pattern to determine whether or not it matches, and in the process of
running it hits the print statement before it discovers that we don't
have a match.

To take a closer look at how the engine does optimizations, see the
section L<"Pragmas and debugging"> below.

More fun with C<?{}>:

    $x =~ /(?{print "Hi Mom!";})/;       # matches,
                                         # prints 'Hi Mom!'
    $x =~ /(?{$c = 1;})(?{print "$c";})/;  # matches,
                                           # prints '1'
    $x =~ /(?{$c = 1;})(?{print "$^R";})/; # matches,
                                           # prints '1'

The bit of magic mentioned in the section title occurs when the regexp
backtracks in the process of searching for a match.  If the regexp
backtracks over a code expression and if the variables used within are
localized using C<local>, the changes in the variables produced by the
code expression are undone! Thus, if we wanted to count how many times
a character got matched inside a group, we could use, e.g.,

    $x = "aaaa";
    $count = 0;  # initialize 'a' count
    $c = "bob";  # test if $c gets clobbered
    $x =~ /(?{local $c = 0;})         # initialize count
           ( a                        # match 'a'
             (?{local $c = $c + 1;})  # increment count
           )*                         # do this any number of times,
           aa                         # but match 'aa' at the end
           (?{$count = $c;})          # copy local $c var into $count
          /x;
    print "'a' count is $count, \$c variable is '$c'\n";

This prints

    'a' count is 2, $c variable is 'bob'

If we replace the S<C< (?{local $c = $c + 1;})>> with
S<C< (?{$c = $c + 1;})>>, the variable changes are I<not> undone
during backtracking, and we get

    'a' count is 4, $c variable is 'bob'

Note that only localized variable changes are undone.  Other side
effects of code expression execution are permanent.  Òàêèì îáðàçîì

    $x = "aaaa";
    $x =~ /(a(?{print "Yow\n";}))*aa/;

produces

   Yow
   Yow
   Yow
   Yow

The result C<$^R> is automatically localized, so that it will behave
properly in the presence of backtracking.

This example uses a code expression in a conditional to match a
definite article, either 'the' in English or 'der|die|das' in German:

    $lang = 'DE';  # use German
    ...
    $text = "das";
    print "matched\n"
        if $text =~ /(?(?{
                          $lang eq 'EN'; # is the language English?
                         })
                       the |             # if so, then match 'the'
                       (der|die|das)     # else, match 'der|die|das'
                     )
                    /xi;

Note that the syntax here is C<(?(?{...})yes-regexp|no-regexp)>, not
C<(?((?{...}))yes-regexp|no-regexp)>.  In other words, in the case of a
code expression, we don't need the extra parentheses around the
conditional.

If you try to use code expressions where the code text is contained within
an interpolated variable, rather than appearing literally in the pattern,
Perl may surprise you:

    $bar = 5;
    $pat = '(?{ 1 })';
    /foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
    /foo(?{ 1 })$bar/;   # compiles ok, $bar interpolated
    /foo${pat}bar/;      # compile error!

    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
    /foo${pat}bar/;      # compiles ok

If a regexp has a variable that interpolates a code expression, Perl
treats the regexp as an error. If the code expression is precompiled into
a variable, however, interpolating is ok. The question is, why is this an
error?

The reason is that variable interpolation and code expressions
together pose a security risk.  The combination is dangerous because
many programmers who write search engines often take user input and
plug it directly into a regexp:

    $regexp = <>;       # read user-supplied regexp
    $chomp $regexp;     # get rid of possible newline
    $text =~ /$regexp/; # search $text for the $regexp

If the C<$regexp> variable contains a code expression, the user could
then execute arbitrary Perl code.  For instance, some joker could
search for S<C<system('rm -rf *');>> to erase your files.  In this
sense, the combination of interpolation and code expressions I<taints>
your regexp.  So by default, using both interpolation and code
expressions in the same regexp is not allowed.  If you're not
concerned about malicious users, it is possible to bypass this
security check by invoking S<C<use re 'eval'>>:

    use re 'eval';       # throw caution out the door
    $bar = 5;
    $pat = '(?{ 1 })';
    /foo${pat}bar/;      # compiles ok

Another form of code expression is the I<pattern code expression>.
The pattern code expression is like a regular code expression, except
that the result of the code evaluation is treated as a regular
expression and matched immediately.  A simple example is

    $length = 5;
    $char = 'a';
    $x = 'aaaaabb';
    $x =~ /(??{$char x $length})/x; # matches, there are 5 of 'a'


This final example contains both ordinary and pattern code
expressions.  It detects whether a binary string C<1101010010001...> has a
Fibonacci spacing 0,1,1,2,3,5,...  of the C<1>'s:

    $x = "1101010010001000001";
    $z0 = ''; $z1 = '0';   # initial conditions
    print "It is a Fibonacci sequence\n"
        if $x =~ /^1         # match an initial '1'
                    (?:
                       ((??{ $z0 })) # match some '0'
                       1             # and then a '1'
		       (?{ $z0 = $z1; $z1 .= $^N; })
                    )+   # repeat as needed
                  $      # that is all there is
                 /x;
    printf "Largest sequence matched was %d\n", length($z1)-length($z0);

Remember that C<$^N> is set to whatever was matched by the last
completed capture group. This prints

    It is a Fibonacci sequence
    Largest sequence matched was 5

Ha! Try that with your garden variety regexp package...

Note that the variables C<$z0> and C<$z1> are not substituted when the
regexp is compiled, as happens for ordinary variables outside a code
expression.  Rather, the whole code block is parsed as perl code at the
same time as perl is compiling the code containing the literal regexp
pattern.

The regexp without the C<//x> modifier is

    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/

which shows that spaces are still possible in the code parts. Nevertheless,
when working with code and conditional expressions, the extended form of
regexps is almost necessary in creating and debugging regexps.


=head2 Backtracking control verbs

Perl 5.10 introduced a number of control verbs intended to provide
detailed control over the backtracking process, by directly influencing
the regexp engine and by providing monitoring techniques.  As all
the features in this group are experimental and subject to change or
removal in a future version of Perl, the interested reader is
referred to L<perlre/"Special Backtracking Control Verbs"> for a
detailed description.

Below is just one example, illustrating the control verb C<(*FAIL)>,
which may be abbreviated as C<(*F)>. If this is inserted in a regexp
it will cause it to fail, just as it would at some
mismatch between the pattern and the string. Processing
of the regexp continues as it would after any "normal"
failure, so that, for instance, the next position in the string or another
alternative will be tried. As failing to match doesn't preserve capture
groups or produce results, it may be necessary to use this in
combination with embedded code.

   %count = ();
   "supercalifragilisticexpialidocious" =~
       /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
   printf "%3d '%s'\n", $count{$_}, $_ for (sort keys %count);

The pattern begins with a class matching a subset of letters.  Whenever
this matches, a statement like C<$count{'a'}++;> is executed, incrementing
the letter's counter. Then C<(*FAIL)> does what it says, and
the regexp engine proceeds according to the book: as long as the end of
the string hasn't been reached, the position is advanced before looking
for another vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the entire string has been inspected.
(It's remarkable that an alternative solution using something like

   $count{lc($_)}++ for split('', "supercalifragilisticexpialidocious");
   printf "%3d '%s'\n", $count2{$_}, $_ for ( qw{ a e i o u } );

is considerably slower.)


=head2 Pragmas and debugging

Speaking of debugging, there are several pragmas available to control
and debug regexps in Perl.  We have already encountered one pragma in
the previous section, S<C<use re 'eval';>>, that allows variable
interpolation and code expressions to coexist in a regexp.  The other
pragmas are

    use re 'taint';
    $tainted = <>;
    @parts = ($tainted =~ /(\w+)\s+(\w+)/; # @parts is now tainted

The C<taint> pragma causes any substrings from a match with a tainted
variable to be tainted as well.  This is not normally the case, as
regexps are often used to extract the safe bits from a tainted
variable.  Use C<taint> when you are not extracting safe bits, but are
performing some other processing.  Both C<taint> and C<eval> pragmas
are lexically scoped, which means they are in effect only until
the end of the block enclosing the pragmas.

    use re '/m';  # or any other flags
    $multiline_string =~ /^foo/; # /m is implied

The C<re '/flags'> pragma (introduced in Perl
5.14) turns on the given regular expression flags
until the end of the lexical scope.  See
L<re/"'E<sol>flags' mode"> for more
detail.

    use re 'debug';
    /^(.*)$/s;       # output debugging info

    use re 'debugcolor';
    /^(.*)$/s;       # output debugging info in living color

The global C<debug> and C<debugcolor> pragmas allow one to get
detailed debugging info about regexp compilation and
execution.  C<debugcolor> is the same as debug, except the debugging
information is displayed in color on terminals that can display
termcap color sequences.  Here is example output:

    % perl -e 'use re "debug"; "abc" =~ /a*b+c/;'
    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT <a>(0)
       4: PLUS(7)
       5:   EXACT <b>(0)
       7: EXACT <c>(9)
       9: END(0)
    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0
    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 <> <abc>             |  1:  STAR
                               EXACT <a> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 <a> <bc>             |  4:    PLUS
                               EXACT <b> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 <ab> <c>             |  7:      EXACT <c>
       3 <abc> <>             |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'

If you have gotten this far into the tutorial, you can probably guess
what the different parts of the debugging output tell you.  The first
part

    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT <a>(0)
       4: PLUS(7)
       5:   EXACT <b>(0)
       7: EXACT <c>(9)
       9: END(0)

describes the compilation stage.  C<STAR(4)> means that there is a
starred object, in this case C<'a'>, and if it matches, goto line 4,
i.e., C<PLUS(7)>.  The middle lines describe some heuristics and
optimizations performed before a match:

    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0

Then the match is executed and the remaining lines describe the
process:

    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 <> <abc>             |  1:  STAR
                               EXACT <a> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 <a> <bc>             |  4:    PLUS
                               EXACT <b> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 <ab> <c>             |  7:      EXACT <c>
       3 <abc> <>             |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'

Each step is of the form S<C<< n <x> <y> >>>, with C<< <x> >> the
part of the string matched and C<< <y> >> the part not yet
matched.  The S<C<< |  1:  STAR >>> says that Perl is at line number 1
in the compilation list above.  See
L<perldebguts/"Debugging Regular Expressions"> for much more detail.

An alternative method of debugging regexps is to embed C<print>
statements within the regexp.  This provides a blow-by-blow account of
the backtracking in an alternation:

    "that this" =~ m@(?{print "Start at position ", pos, "\n";})
                     t(?{print "t1\n";})
                     h(?{print "h1\n";})
                     i(?{print "i1\n";})
                     s(?{print "s1\n";})
                         |
                     t(?{print "t2\n";})
                     h(?{print "h2\n";})
                     a(?{print "a2\n";})
                     t(?{print "t2\n";})
                     (?{print "Done at position ", pos, "\n";})
                    @x;

prints

    Start at position 0
    t1
    h1
    t2
    h2
    a2
    t2
    Done at position 4

=head1 BUGS

Code expressions, conditional expressions, and independent expressions
are I<experimental>.  Don't use them in production code.  Yet.

=head1 SEE ALSO

This is just a tutorial.  For the full story on Perl regular
expressions, see the L<perlre> regular expressions reference page.

For more information on the matching C<m//> and substitution C<s///>
operators, see L<perlop/"Regexp Quote-Like Operators">.  For
information on the C<split> operation, see L<perlfunc/split>.

For an excellent all-around resource on the care and feeding of
regular expressions, see the book I<Mastering Regular Expressions> by
Jeffrey Friedl (published by O'Reilly, ISBN 1556592-257-3).

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 2000 Mark Kvale
All rights reserved.

This document may be distributed under the same terms as Perl itself.

=head2 Acknowledgments

The inspiration for the stop codon DNA example came from the ZIP
code example in chapter 7 of I<Mastering Regular Expressions>.

The author would like to thank Jeff Pinyan, Andrew Johnson, Peter
Haworth, Ronald J Kimball, and Joe Smith for all their helpful
comments.


=head1 ПЕРЕВОДЧИКИ
 
=over
 
=item * Николай Мишин C<< <mishin@cpan.org> >>
 
=back


